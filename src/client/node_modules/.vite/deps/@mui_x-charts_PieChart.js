import {
  NoSsr_default
} from "./chunk-ULGUKDQN.js";
import {
  ANIMATION_DURATION_MS,
  ANIMATION_TIMING_FUNCTION,
  ChartProvider,
  ChartsLocalizationProvider,
  ChartsSurface,
  DEFAULT_PIE_CHART_MARGIN,
  createSelector,
  createSelectorMemoizedWithOptions,
  defaultizeMargin,
  deg2rad,
  generateSvg2rotation,
  getAxisIndex,
  getLabel,
  getPercentageValue,
  getPieCoordinates,
  getSVGPoint,
  isCartesianSeries,
  isCartesianSeriesType,
  isDeepEqual,
  isOrdinalScale,
  isPolarSeriesType,
  selectorBrushShouldPreventTooltip,
  selectorChartAxisZoomData,
  selectorChartDrawingArea,
  selectorChartPolarCenter,
  selectorChartPropsHeight,
  selectorChartPropsWidth,
  selectorChartRawRotationAxis,
  selectorChartRawXAxis,
  selectorChartRotationAxis,
  selectorChartSeriesConfig,
  selectorChartSeriesEmptyFlatbushMap,
  selectorChartSeriesFlatbushMap,
  selectorChartSeriesProcessed,
  selectorChartXAxis,
  selectorChartYAxis,
  selectorChartZoomIsInteracting,
  selectorChartsFocusedDataIndex,
  selectorChartsFocusedSeriesId,
  selectorChartsFocusedSeriesType,
  selectorChartsInteractionAxisTooltip,
  selectorChartsInteractionPointerX,
  selectorChartsInteractionPointerY,
  selectorChartsInteractionTooltipXAxes,
  selectorChartsInteractionTooltipYAxes,
  selectorChartsLastInteraction,
  selectorChartsTooltipItem,
  selectorChartsTooltipItemIsDefined,
  selectorChartsTooltipItemPosition,
  useAnimatePieArc,
  useAnimatePieArcLabel,
  useChartBrush,
  useChartCartesianAxis,
  useChartContext,
  useChartGradientIdObjectBoundBuilder,
  useChartHighlight,
  useChartInteraction,
  useChartKeyboardNavigation,
  useChartRootRef,
  useChartZAxis,
  useChartsLocalization,
  useDrawingArea,
  useItemHighlightedGetter,
  useLegend,
  usePieSeriesContext,
  useRotationAxes,
  useRotationAxis,
  useSelector,
  useSeries,
  useSkipAnimation,
  useStore,
  useSvgRef,
  useXAxes,
  useXAxis,
  useYAxes,
  useYAxis,
  useZAxes
} from "./chunk-B7TM23NM.js";
import "./chunk-IIUSGDYG.js";
import "./chunk-7JXIQDJB.js";
import {
  useMediaQuery_default
} from "./chunk-YUXYOW7B.js";
import {
  Button_default
} from "./chunk-CWP6AOA3.js";
import {
  Typography_default
} from "./chunk-ZHI4TUXH.js";
import {
  Popper_default
} from "./chunk-KKBVHARI.js";
import {
  HTMLElementType,
  useSlotProps_default
} from "./chunk-XO4Z3DFG.js";
import "./chunk-SNEEUS56.js";
import {
  useThemeProps
} from "./chunk-JQYOTNOF.js";
import {
  IconButton_default
} from "./chunk-IT32MZKQ.js";
import "./chunk-UNN4XOOX.js";
import "./chunk-GNM62ZLU.js";
import "./chunk-IVRNDVZX.js";
import "./chunk-YHTBL3B6.js";
import "./chunk-K2SGXQ2U.js";
import "./chunk-7UG5JFOM.js";
import {
  useLazyRef
} from "./chunk-LIXSN4EE.js";
import {
  _objectWithoutPropertiesLoose
} from "./chunk-BFL632LT.js";
import "./chunk-B7QPRFY7.js";
import "./chunk-ZCSSBJ3Q.js";
import "./chunk-ITGWAFDM.js";
import "./chunk-2FJKP7NC.js";
import "./chunk-4RM4DTC2.js";
import "./chunk-24EJ2AYK.js";
import "./chunk-ZEIXWUU4.js";
import "./chunk-SUSNWJV4.js";
import "./chunk-W6AGLKDN.js";
import {
  useEventCallback_default,
  useForkRef
} from "./chunk-754CCMWI.js";
import "./chunk-75SYLN5K.js";
import "./chunk-UBFBXXFB.js";
import {
  useTheme
} from "./chunk-BPTAPQKP.js";
import "./chunk-SZFUZPID.js";
import "./chunk-INMGU2AI.js";
import {
  clsx_default,
  composeClasses,
  generateUtilityClass,
  generateUtilityClasses,
  resolveProps,
  shouldForwardProp,
  styled_default,
  useEnhancedEffect_default,
  useId,
  useRtl
} from "./chunk-PL2COC37.js";
import {
  require_jsx_runtime
} from "./chunk-7VXJSGHI.js";
import {
  require_prop_types
} from "./chunk-FUOYWSSY.js";
import "./chunk-ANHDWAXR.js";
import "./chunk-4JLRNKH6.js";
import {
  _extends
} from "./chunk-EQCCHGRT.js";
import {
  require_react
} from "./chunk-ZXCIKYUC.js";
import {
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/@mui/x-charts/esm/PieChart/PieChart.js
var React29 = __toESM(require_react(), 1);
var import_prop_types20 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsTooltip.js
var import_prop_types5 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsItemTooltipContent.js
var import_prop_types2 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsTooltip/chartsTooltipClasses.js
function getChartsTooltipUtilityClass(slot) {
  return generateUtilityClass("MuiChartsTooltip", slot);
}
var chartsTooltipClasses = generateUtilityClasses("MuiChartsTooltip", ["root", "paper", "table", "row", "cell", "mark", "markContainer", "labelCell", "valueCell", "axisValueCell"]);
var useUtilityClasses = (classes) => {
  const slots = {
    root: ["root"],
    paper: ["paper"],
    table: ["table"],
    row: ["row"],
    cell: ["cell"],
    mark: ["mark"],
    markContainer: ["markContainer"],
    labelCell: ["labelCell"],
    valueCell: ["valueCell"],
    axisValueCell: ["axisValueCell"]
  };
  return composeClasses(slots, getChartsTooltipUtilityClass, classes);
};

// node_modules/@mui/x-charts/esm/ChartsTooltip/useItemTooltip.js
function useInternalItemTooltip() {
  var _a, _b, _c;
  const store = useStore();
  const identifier = useSelector(store, selectorChartsTooltipItem);
  const seriesConfig = useSelector(store, selectorChartSeriesConfig);
  const series = useSeries();
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const {
    zAxis,
    zAxisIds
  } = useZAxes();
  const {
    rotationAxis,
    rotationAxisIds
  } = useRotationAxes();
  if (!identifier) {
    return null;
  }
  const itemSeries = (_a = series[identifier.type]) == null ? void 0 : _a.series[identifier.seriesId];
  if (!itemSeries) {
    return null;
  }
  const xAxisId = isCartesianSeries(itemSeries) ? itemSeries.xAxisId ?? xAxisIds[0] : void 0;
  const yAxisId = isCartesianSeries(itemSeries) ? itemSeries.yAxisId ?? yAxisIds[0] : void 0;
  const zAxisId = "zAxisId" in itemSeries ? itemSeries.zAxisId ?? zAxisIds[0] : zAxisIds[0];
  const rotationAxisId = rotationAxisIds[0];
  const getColor = ((_c = (_b = seriesConfig[itemSeries.type]).colorProcessor) == null ? void 0 : _c.call(_b, itemSeries, xAxisId !== void 0 ? xAxis[xAxisId] : void 0, yAxisId !== void 0 ? yAxis[yAxisId] : void 0, zAxisId !== void 0 ? zAxis[zAxisId] : void 0)) ?? (() => "");
  const axesConfig = {};
  if (xAxisId !== void 0) {
    axesConfig.x = xAxis[xAxisId];
  }
  if (yAxisId !== void 0) {
    axesConfig.y = yAxis[yAxisId];
  }
  if (rotationAxisId !== void 0) {
    axesConfig.rotation = rotationAxis[rotationAxisId];
  }
  return seriesConfig[itemSeries.type].tooltipGetter({
    series: itemSeries,
    axesConfig,
    getColor,
    identifier
  });
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsTooltipTable.js
var ChartsTooltipPaper = styled_default("div", {
  name: "MuiChartsTooltip",
  slot: "Container",
  overridesResolver: (props, styles) => styles.paper
  // FIXME: Inconsistent naming with slot
})(({
  theme
}) => {
  var _a;
  return {
    backgroundColor: (theme.vars || theme).palette.background.paper,
    color: (theme.vars || theme).palette.text.primary,
    borderRadius: (_a = (theme.vars || theme).shape) == null ? void 0 : _a.borderRadius,
    border: `solid ${(theme.vars || theme).palette.divider} 1px`
  };
});
var ChartsTooltipTable = styled_default("table", {
  name: "MuiChartsTooltip",
  slot: "Table"
})(({
  theme
}) => ({
  borderSpacing: 0,
  [`& .${chartsTooltipClasses.markContainer}`]: {
    display: "inline-block",
    width: `calc(20px + ${theme.spacing(1.5)})`,
    verticalAlign: "middle"
  },
  "& caption": {
    borderBottom: `solid ${(theme.vars || theme).palette.divider} 1px`,
    padding: theme.spacing(0.5, 1.5),
    textAlign: "start",
    whiteSpace: "nowrap",
    "& span": {
      marginRight: theme.spacing(1.5)
    }
  }
}));
var ChartsTooltipRow = styled_default("tr", {
  name: "MuiChartsTooltip",
  slot: "Row"
})(({
  theme
}) => ({
  "tr:first-of-type& td": {
    paddingTop: theme.spacing(0.5)
  },
  "tr:last-of-type& td": {
    paddingBottom: theme.spacing(0.5)
  }
}));
var ChartsTooltipCell = styled_default(Typography_default, {
  name: "MuiChartsTooltip",
  slot: "Cell"
})(({
  theme
}) => ({
  verticalAlign: "middle",
  color: (theme.vars || theme).palette.text.secondary,
  textAlign: "start",
  [`&.${chartsTooltipClasses.cell}`]: {
    paddingLeft: theme.spacing(1),
    paddingRight: theme.spacing(1)
  },
  [`&.${chartsTooltipClasses.labelCell}`]: {
    whiteSpace: "nowrap",
    fontWeight: theme.typography.fontWeightRegular
  },
  [`&.${chartsTooltipClasses.valueCell}, &.${chartsTooltipClasses.axisValueCell}`]: {
    color: (theme.vars || theme).palette.text.primary,
    fontWeight: theme.typography.fontWeightMedium
  },
  [`&.${chartsTooltipClasses.valueCell}`]: {
    paddingLeft: theme.spacing(1.5),
    paddingRight: theme.spacing(1.5)
  },
  "td:first-of-type&, th:first-of-type&": {
    paddingLeft: theme.spacing(1.5)
  },
  "td:last-of-type&, th:last-of-type&": {
    paddingRight: theme.spacing(1.5)
  }
}));

// node_modules/@mui/x-charts/esm/ChartsLabel/ChartsLabelMark.js
var React2 = __toESM(require_react(), 1);
var import_prop_types = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsLabel/labelMarkClasses.js
function getLabelMarkUtilityClass(slot) {
  return generateUtilityClass("MuiChartsLabelMark", slot);
}
var labelMarkClasses = generateUtilityClasses("MuiChartsLabelMark", ["root", "line", "square", "circle", "mask", "fill"]);
var useUtilityClasses2 = (props) => {
  const {
    type
  } = props;
  const slots = {
    root: typeof type === "function" ? ["root"] : ["root", type],
    mask: ["mask"],
    fill: ["fill"]
  };
  return composeClasses(slots, getLabelMarkUtilityClass, props.classes);
};

// node_modules/@mui/x-charts/esm/internals/consumeThemeProps.js
var React = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var consumeThemeProps = (name, options, InComponent) => React.forwardRef(function ConsumeThemeInternal(props, ref) {
  var _a;
  const themedProps = useThemeProps({
    props,
    // eslint-disable-next-line material-ui/mui-name-matches-component-name
    name
  });
  const defaultProps = typeof options.defaultProps === "function" ? options.defaultProps(themedProps) : options.defaultProps ?? {};
  const outProps = resolveProps(defaultProps, themedProps);
  const theme = useTheme();
  const classes = (_a = options.classesResolver) == null ? void 0 : _a.call(options, outProps, theme);
  const OutComponent = React.forwardRef(InComponent);
  if (true) OutComponent.displayName = "OutComponent";
  if (true) {
    OutComponent.displayName = `consumeThemeProps(${name})`;
  }
  return (0, import_jsx_runtime.jsx)(OutComponent, _extends({}, outProps, {
    classes,
    ref
  }));
});
if (true) consumeThemeProps.displayName = "consumeThemeProps";

// node_modules/@mui/x-charts/esm/ChartsLabel/ChartsLabelMark.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var _excluded = ["type", "color", "className", "classes"];
var Root = styled_default("div", {
  name: "MuiChartsLabelMark",
  slot: "Root"
})(() => {
  return {
    display: "flex",
    width: 14,
    height: 14,
    [`&.${labelMarkClasses.line}`]: {
      width: 16,
      height: "unset",
      alignItems: "center",
      [`.${labelMarkClasses.mask}`]: {
        height: 4,
        width: "100%",
        borderRadius: 1,
        overflow: "hidden"
      }
    },
    [`&.${labelMarkClasses.square}`]: {
      height: 13,
      width: 13,
      borderRadius: 2,
      overflow: "hidden"
    },
    [`&.${labelMarkClasses.circle}`]: {
      height: 15,
      width: 15
    },
    svg: {
      display: "block"
    },
    [`& .${labelMarkClasses.mask} > *`]: {
      height: "100%",
      width: "100%"
    },
    [`& .${labelMarkClasses.mask}`]: {
      height: "100%",
      width: "100%"
    }
  };
});
var ChartsLabelMark = consumeThemeProps("MuiChartsLabelMark", {
  defaultProps: {
    type: "square"
  },
  classesResolver: useUtilityClasses2
}, function ChartsLabelMark2(props, ref) {
  const {
    type,
    color,
    className,
    classes
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
  const Component = type;
  return (0, import_jsx_runtime2.jsx)(Root, _extends({
    className: clsx_default(classes == null ? void 0 : classes.root, className),
    ownerState: props,
    "aria-hidden": "true",
    ref
  }, other, {
    children: (0, import_jsx_runtime2.jsx)("div", {
      className: classes == null ? void 0 : classes.mask,
      children: typeof Component === "function" ? (0, import_jsx_runtime2.jsx)(Component, {
        className: classes == null ? void 0 : classes.fill,
        color
      }) : (0, import_jsx_runtime2.jsx)("svg", {
        viewBox: "0 0 24 24",
        preserveAspectRatio: type === "line" ? "none" : void 0,
        children: type === "circle" ? (0, import_jsx_runtime2.jsx)("circle", {
          className: classes == null ? void 0 : classes.fill,
          r: "12",
          cx: "12",
          cy: "12",
          fill: color
        }) : (0, import_jsx_runtime2.jsx)("rect", {
          className: classes == null ? void 0 : classes.fill,
          width: "24",
          height: "24",
          fill: color
        })
      })
    })
  }));
});
true ? ChartsLabelMark.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types.default.object,
  /**
   * The color of the mark.
   */
  color: import_prop_types.default.string,
  /**
   * The type of the mark.
   * @default 'square'
   */
  type: import_prop_types.default.oneOf(["circle", "line", "square"])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsItemTooltipContent.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
function ChartsItemTooltipContent(props) {
  const {
    classes: propClasses,
    sx
  } = props;
  const tooltipData = useInternalItemTooltip();
  const classes = useUtilityClasses(propClasses);
  if (!tooltipData) {
    return null;
  }
  if ("values" in tooltipData) {
    const {
      label: seriesLabel,
      color: color2,
      markType: markType2
    } = tooltipData;
    return (0, import_jsx_runtime3.jsx)(ChartsTooltipPaper, {
      sx,
      className: classes.paper,
      children: (0, import_jsx_runtime3.jsxs)(ChartsTooltipTable, {
        className: classes.table,
        children: [(0, import_jsx_runtime3.jsxs)(Typography_default, {
          component: "caption",
          children: [(0, import_jsx_runtime3.jsx)("div", {
            className: classes.markContainer,
            children: (0, import_jsx_runtime3.jsx)(ChartsLabelMark, {
              type: markType2,
              color: color2,
              className: classes.mark
            })
          }), seriesLabel]
        }), (0, import_jsx_runtime3.jsx)("tbody", {
          children: tooltipData.values.map(({
            formattedValue: formattedValue2,
            label: label2
          }) => (0, import_jsx_runtime3.jsxs)(ChartsTooltipRow, {
            className: classes.row,
            children: [(0, import_jsx_runtime3.jsx)(ChartsTooltipCell, {
              className: clsx_default(classes.labelCell, classes.cell),
              component: "th",
              children: label2
            }), (0, import_jsx_runtime3.jsx)(ChartsTooltipCell, {
              className: clsx_default(classes.valueCell, classes.cell),
              component: "td",
              children: formattedValue2
            })]
          }, label2))
        })]
      })
    });
  }
  const {
    color,
    label,
    formattedValue,
    markType
  } = tooltipData;
  return (0, import_jsx_runtime3.jsx)(ChartsTooltipPaper, {
    sx,
    className: classes.paper,
    children: (0, import_jsx_runtime3.jsx)(ChartsTooltipTable, {
      className: classes.table,
      children: (0, import_jsx_runtime3.jsx)("tbody", {
        children: (0, import_jsx_runtime3.jsxs)(ChartsTooltipRow, {
          className: classes.row,
          children: [(0, import_jsx_runtime3.jsxs)(ChartsTooltipCell, {
            className: clsx_default(classes.labelCell, classes.cell),
            component: "th",
            children: [(0, import_jsx_runtime3.jsx)("div", {
              className: classes.markContainer,
              children: (0, import_jsx_runtime3.jsx)(ChartsLabelMark, {
                type: markType,
                color,
                className: classes.mark
              })
            }), label]
          }), (0, import_jsx_runtime3.jsx)(ChartsTooltipCell, {
            className: clsx_default(classes.valueCell, classes.cell),
            component: "td",
            children: formattedValue
          })]
        })
      })
    })
  });
}
true ? ChartsItemTooltipContent.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types2.default.object,
  sx: import_prop_types2.default.oneOfType([import_prop_types2.default.arrayOf(import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.object, import_prop_types2.default.bool])), import_prop_types2.default.func, import_prop_types2.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsAxisTooltipContent.js
var import_prop_types3 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/internals/plugins/corePlugins/useChartSeries/useColorProcessor.js
var React3 = __toESM(require_react(), 1);
function useColorProcessor(seriesType) {
  const store = useStore();
  const seriesConfig = useSelector(store, selectorChartSeriesConfig);
  const colorProcessors = React3.useMemo(() => {
    const rep = {};
    Object.keys(seriesConfig).forEach((seriesT) => {
      rep[seriesT] = seriesConfig[seriesT].colorProcessor;
    });
    return rep;
  }, [seriesConfig]);
  if (!seriesType) {
    return colorProcessors;
  }
  return colorProcessors[seriesType];
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/utils.js
var React4 = __toESM(require_react(), 1);
function usePointerType() {
  const svgRef = useSvgRef();
  const [pointerType, setPointerType] = React4.useState(null);
  React4.useEffect(() => {
    const element = svgRef.current;
    if (element === null) {
      return () => {
      };
    }
    const handleOut = (event) => {
      if (event.pointerType !== "mouse") {
        setPointerType(null);
      }
    };
    const handleEnter = (event) => {
      setPointerType({
        pointerType: event.pointerType
      });
    };
    element.addEventListener("pointerenter", handleEnter);
    element.addEventListener("pointerup", handleOut);
    return () => {
      element.removeEventListener("pointerenter", handleEnter);
      element.removeEventListener("pointerup", handleOut);
    };
  }, [svgRef]);
  return pointerType;
}
function utcFormatter(v) {
  if (v instanceof Date) {
    return v.toUTCString();
  }
  return v.toLocaleString();
}
var mainPointerFineMediaQuery = "@media (pointer: fine)";
var useIsFineMainPointer = () => {
  return useMediaQuery_default(mainPointerFineMediaQuery, {
    defaultMatches: true
  });
};

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartPolarAxis/useChartPolarInteraction.selectors.js
var optionalGetAxisId = (_, id) => id;
var optionalGetAxisIds = (_, ids) => ids;
function indexGetter(value, axes, ids) {
  return Array.isArray(ids) ? ids.map((id) => getAxisIndex(axes.axis[id], value)) : getAxisIndex(axes.axis[ids], value);
}
var selectorChartsInteractionRotationAngle = createSelector([selectorChartsInteractionPointerX, selectorChartsInteractionPointerY, selectorChartPolarCenter], (x, y, center) => {
  if (x === null || y === null) {
    return null;
  }
  return generateSvg2rotation(center)(x, y);
});
var selectorChartsInteractionRotationAxisIndex = createSelector([selectorChartsInteractionRotationAngle, selectorChartRotationAxis, optionalGetAxisId], (rotation, rotationAxis, id = rotationAxis.axisIds[0]) => rotation === null ? null : indexGetter(rotation, rotationAxis, id));
var selectorChartsInteractionRotationAxisIndexes = createSelector([selectorChartsInteractionRotationAngle, selectorChartRotationAxis, optionalGetAxisIds], (rotation, rotationAxis, ids = rotationAxis.axisIds) => rotation === null ? null : indexGetter(rotation, rotationAxis, ids));
var selectorChartsInteractionRotationAxisValue = createSelector([selectorChartRotationAxis, selectorChartsInteractionRotationAxisIndex, optionalGetAxisId], (rotationAxis, rotationIndex, id = rotationAxis.axisIds[0]) => {
  var _a;
  if (rotationIndex === null || rotationIndex === -1 || rotationAxis.axisIds.length === 0) {
    return null;
  }
  const data = (_a = rotationAxis.axis[id]) == null ? void 0 : _a.data;
  if (!data) {
    return null;
  }
  return data[rotationIndex];
});
var selectorChartsInteractionRotationAxisValues = createSelector([selectorChartRotationAxis, selectorChartsInteractionRotationAxisIndexes, optionalGetAxisIds], (rotationAxis, rotationIndexes, ids = rotationAxis.axisIds) => {
  if (rotationIndexes === null) {
    return null;
  }
  return ids.map((id, axisIndex) => {
    var _a;
    const rotationIndex = rotationIndexes[axisIndex];
    if (rotationIndex === -1) {
      return null;
    }
    return (_a = rotationAxis.axis[id].data) == null ? void 0 : _a[rotationIndex];
  });
});
var selectorChartsInteractionTooltipRotationAxes = createSelectorMemoizedWithOptions({
  memoizeOptions: {
    // Keep the same reference if array content is the same.
    // If possible, avoid this pattern by creating selectors that
    // uses string/number as arguments.
    resultEqualityCheck: isDeepEqual
  }
})(selectorChartsInteractionRotationAxisIndexes, selectorChartRotationAxis, (indexes, axes) => {
  if (indexes === null) {
    return [];
  }
  return axes.axisIds.map((axisId, axisIndex) => ({
    axisId,
    dataIndex: indexes[axisIndex]
  })).filter(({
    axisId,
    dataIndex
  }) => axes.axis[axisId].triggerTooltip && dataIndex >= 0);
});
var selectorChartsInteractionPolarAxisTooltip = createSelector([selectorChartsInteractionTooltipRotationAxes], (rotationTooltip) => rotationTooltip.length > 0);

// node_modules/@mui/x-charts/esm/ChartsTooltip/useAxisTooltip.js
function defaultAxisTooltipConfig(axis, dataIndex, axisDirection) {
  var _a;
  const axisValue = ((_a = axis.data) == null ? void 0 : _a[dataIndex]) ?? null;
  const axisFormatter = axis.valueFormatter ?? ((v) => axis.scaleType === "utc" ? utcFormatter(v) : v.toLocaleString());
  const axisFormattedValue = axisFormatter(axisValue, {
    location: "tooltip",
    scale: axis.scale
  });
  return {
    axisDirection,
    axisId: axis.id,
    mainAxis: axis,
    dataIndex,
    axisValue,
    axisFormattedValue,
    seriesItems: []
  };
}
function useAxisTooltip(params = {}) {
  const {
    multipleAxes,
    directions
  } = params;
  const defaultXAxis = useXAxis();
  const defaultYAxis = useYAxis();
  const defaultRotationAxis = useRotationAxis();
  const store = useStore();
  const tooltipXAxes = useSelector(store, selectorChartsInteractionTooltipXAxes);
  const tooltipYAxes = useSelector(store, selectorChartsInteractionTooltipYAxes);
  const tooltipRotationAxes = useSelector(store, selectorChartsInteractionTooltipRotationAxes);
  const series = useSeries();
  const {
    xAxis
  } = useXAxes();
  const {
    yAxis
  } = useYAxes();
  const {
    zAxis,
    zAxisIds
  } = useZAxes();
  const {
    rotationAxis
  } = useRotationAxes();
  const colorProcessors = useColorProcessor();
  if (tooltipXAxes.length === 0 && tooltipYAxes.length === 0 && tooltipRotationAxes.length === 0) {
    return null;
  }
  const tooltipAxes = [];
  if (directions === void 0 || directions.includes("x")) {
    tooltipXAxes.forEach(({
      axisId,
      dataIndex
    }) => {
      if (!multipleAxes && tooltipAxes.length > 1) {
        return;
      }
      tooltipAxes.push(defaultAxisTooltipConfig(xAxis[axisId], dataIndex, "x"));
    });
  }
  if (directions === void 0 || directions.includes("y")) {
    tooltipYAxes.forEach(({
      axisId,
      dataIndex
    }) => {
      if (!multipleAxes && tooltipAxes.length > 1) {
        return;
      }
      tooltipAxes.push(defaultAxisTooltipConfig(yAxis[axisId], dataIndex, "y"));
    });
  }
  if (directions === void 0 || directions.includes("rotation")) {
    tooltipRotationAxes.forEach(({
      axisId,
      dataIndex
    }) => {
      if (!multipleAxes && tooltipAxes.length > 1) {
        return;
      }
      tooltipAxes.push(defaultAxisTooltipConfig(rotationAxis[axisId], dataIndex, "rotation"));
    });
  }
  Object.keys(series).filter(isCartesianSeriesType).forEach((seriesType) => {
    const seriesOfType = series[seriesType];
    if (!seriesOfType) {
      return [];
    }
    return seriesOfType.seriesOrder.forEach((seriesId) => {
      var _a;
      const seriesToAdd = seriesOfType.series[seriesId];
      const providedXAxisId = seriesToAdd.xAxisId ?? defaultXAxis.id;
      const providedYAxisId = seriesToAdd.yAxisId ?? defaultYAxis.id;
      const tooltipItemIndex = tooltipAxes.findIndex(({
        axisDirection,
        axisId
      }) => axisDirection === "x" && axisId === providedXAxisId || axisDirection === "y" && axisId === providedYAxisId);
      if (tooltipItemIndex >= 0) {
        const zAxisId = "zAxisId" in seriesToAdd ? seriesToAdd.zAxisId : zAxisIds[0];
        const {
          dataIndex
        } = tooltipAxes[tooltipItemIndex];
        const color = ((_a = colorProcessors[seriesType]) == null ? void 0 : _a.call(colorProcessors, seriesToAdd, xAxis[providedXAxisId], yAxis[providedYAxisId], zAxisId ? zAxis[zAxisId] : void 0)(dataIndex)) ?? "";
        const value = seriesToAdd.data[dataIndex] ?? null;
        const formattedValue = seriesToAdd.valueFormatter(value, {
          dataIndex
        });
        const formattedLabel = getLabel(seriesToAdd.label, "tooltip") ?? null;
        tooltipAxes[tooltipItemIndex].seriesItems.push({
          seriesId,
          color,
          value,
          formattedValue,
          formattedLabel,
          markType: seriesToAdd.labelMarkType
        });
      }
    });
  });
  Object.keys(series).filter(isPolarSeriesType).forEach((seriesType) => {
    const seriesOfType = series[seriesType];
    if (!seriesOfType) {
      return [];
    }
    return seriesOfType.seriesOrder.forEach((seriesId) => {
      var _a;
      const seriesToAdd = seriesOfType.series[seriesId];
      const providedRotationAxisId = (
        // @ts-expect-error Should be fixed when we introduce a polar series with a rotationAxisId
        seriesToAdd.rotationAxisId ?? (defaultRotationAxis == null ? void 0 : defaultRotationAxis.id)
      );
      const tooltipItemIndex = tooltipAxes.findIndex(({
        axisDirection,
        axisId
      }) => axisDirection === "rotation" && axisId === providedRotationAxisId);
      if (tooltipItemIndex >= 0) {
        const {
          dataIndex
        } = tooltipAxes[tooltipItemIndex];
        const color = ((_a = colorProcessors[seriesType]) == null ? void 0 : _a.call(colorProcessors, seriesToAdd)(dataIndex)) ?? "";
        const value = seriesToAdd.data[dataIndex] ?? null;
        const formattedValue = seriesToAdd.valueFormatter(value, {
          dataIndex
        });
        const formattedLabel = getLabel(seriesToAdd.label, "tooltip") ?? null;
        tooltipAxes[tooltipItemIndex].seriesItems.push({
          seriesId,
          color,
          value,
          formattedValue,
          formattedLabel,
          markType: seriesToAdd.labelMarkType
        });
      }
    });
  });
  if (!multipleAxes) {
    return tooltipAxes.length === 0 ? tooltipAxes[0] : null;
  }
  return tooltipAxes;
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/useAxesTooltip.js
function useAxesTooltip(params) {
  return useAxisTooltip(_extends({}, params, {
    multipleAxes: true
  }));
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsAxisTooltipContent.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
function ChartsAxisTooltipContent(props) {
  const classes = useUtilityClasses(props.classes);
  const tooltipData = useAxesTooltip();
  if (tooltipData === null) {
    return null;
  }
  return (0, import_jsx_runtime4.jsx)(ChartsTooltipPaper, {
    sx: props.sx,
    className: classes.paper,
    children: tooltipData.map(({
      axisId,
      mainAxis,
      axisValue,
      axisFormattedValue,
      seriesItems
    }) => {
      return (0, import_jsx_runtime4.jsxs)(ChartsTooltipTable, {
        className: classes.table,
        children: [axisValue != null && !mainAxis.hideTooltip && (0, import_jsx_runtime4.jsx)(Typography_default, {
          component: "caption",
          children: axisFormattedValue
        }), (0, import_jsx_runtime4.jsx)("tbody", {
          children: seriesItems.map(({
            seriesId,
            color,
            formattedValue,
            formattedLabel,
            markType
          }) => {
            if (formattedValue == null) {
              return null;
            }
            return (0, import_jsx_runtime4.jsxs)(ChartsTooltipRow, {
              className: classes.row,
              children: [(0, import_jsx_runtime4.jsxs)(ChartsTooltipCell, {
                className: clsx_default(classes.labelCell, classes.cell),
                component: "th",
                children: [(0, import_jsx_runtime4.jsx)("div", {
                  className: classes.markContainer,
                  children: (0, import_jsx_runtime4.jsx)(ChartsLabelMark, {
                    type: markType,
                    color,
                    className: classes.mark
                  })
                }), formattedLabel || null]
              }), (0, import_jsx_runtime4.jsx)(ChartsTooltipCell, {
                className: clsx_default(classes.valueCell, classes.cell),
                component: "td",
                children: formattedValue
              })]
            }, seriesId);
          })
        })]
      }, axisId);
    })
  });
}
true ? ChartsAxisTooltipContent.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types3.default.object,
  sx: import_prop_types3.default.oneOfType([import_prop_types3.default.arrayOf(import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.object, import_prop_types3.default.bool])), import_prop_types3.default.func, import_prop_types3.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsTooltipContainer.js
var React5 = __toESM(require_react(), 1);
var import_prop_types4 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/node_modules/@mui/x-internals/esm/rafThrottle/rafThrottle.js
function rafThrottle(fn) {
  let lastArgs;
  let rafRef;
  const later = () => {
    rafRef = null;
    fn(...lastArgs);
  };
  function throttled(...args) {
    lastArgs = args;
    if (!rafRef) {
      rafRef = requestAnimationFrame(later);
    }
  }
  throttled.clear = () => {
    if (rafRef) {
      cancelAnimationFrame(rafRef);
      rafRef = null;
    }
  };
  return throttled;
}

// node_modules/@mui/x-charts/esm/hooks/useAxisSystem.js
function useAxisSystem() {
  const store = useStore();
  const rawRotationAxis = useSelector(store, selectorChartRawRotationAxis);
  const rawXAxis = useSelector(store, selectorChartRawXAxis);
  if (rawRotationAxis !== void 0) {
    return "polar";
  }
  if (rawXAxis !== void 0) {
    return "cartesian";
  }
  return "none";
}

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsTooltipContainer.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var _excluded2 = ["trigger", "position", "anchor", "classes", "children"];
var selectorReturnFalse = () => false;
function getIsOpenSelector(trigger, axisSystem, shouldPreventBecauseOfBrush) {
  if (shouldPreventBecauseOfBrush) {
    return selectorReturnFalse;
  }
  if (trigger === "item") {
    return selectorChartsTooltipItemIsDefined;
  }
  if (axisSystem === "polar") {
    return selectorChartsInteractionPolarAxisTooltip;
  }
  if (axisSystem === "cartesian") {
    return selectorChartsInteractionAxisTooltip;
  }
  return selectorReturnFalse;
}
var ChartsTooltipRoot = styled_default(Popper_default, {
  name: "MuiChartsTooltip",
  slot: "Root"
})(({
  theme
}) => ({
  pointerEvents: "none",
  zIndex: theme.zIndex.modal
}));
function ChartsTooltipContainer(inProps) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiChartsTooltipContainer"
  });
  const {
    trigger = "axis",
    position,
    anchor = "pointer",
    classes: propClasses,
    children
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded2);
  const svgRef = useSvgRef();
  const classes = useUtilityClasses(propClasses);
  const pointerType = usePointerType();
  const isFineMainPointer = useIsFineMainPointer();
  const popperRef = React5.useRef(null);
  const positionRef = useLazyRef(() => ({
    x: 0,
    y: 0
  }));
  const axisSystem = useAxisSystem();
  const store = useStore();
  const shouldPreventBecauseOfBrush = useSelector(store, selectorBrushShouldPreventTooltip);
  const isOpen = useSelector(store, getIsOpenSelector(trigger, axisSystem, shouldPreventBecauseOfBrush));
  const lastInteraction = useSelector(store, selectorChartsLastInteraction);
  const computedAnchor = lastInteraction === "keyboard" ? "node" : anchor;
  const itemPosition = useSelector(store, trigger === "item" && computedAnchor === "node" ? selectorChartsTooltipItemPosition : () => null, [position]);
  React5.useEffect(() => {
    const svgElement = svgRef.current;
    if (svgElement === null) {
      return () => {
      };
    }
    if (itemPosition !== null) {
      const positionUpdate = rafThrottle(() => {
        var _a;
        positionRef.current = {
          x: svgElement.getBoundingClientRect().left + ((itemPosition == null ? void 0 : itemPosition.x) ?? 0),
          y: svgElement.getBoundingClientRect().top + ((itemPosition == null ? void 0 : itemPosition.y) ?? 0)
        };
        (_a = popperRef.current) == null ? void 0 : _a.update();
      });
      positionUpdate();
      return () => positionUpdate.clear();
    }
    const pointerUpdate = rafThrottle((x, y) => {
      var _a;
      positionRef.current = {
        x,
        y
      };
      (_a = popperRef.current) == null ? void 0 : _a.update();
    });
    const handlePointerEvent = (event) => {
      pointerUpdate(event.clientX, event.clientY);
    };
    svgElement.addEventListener("pointerdown", handlePointerEvent);
    svgElement.addEventListener("pointermove", handlePointerEvent);
    svgElement.addEventListener("pointerenter", handlePointerEvent);
    return () => {
      svgElement.removeEventListener("pointerdown", handlePointerEvent);
      svgElement.removeEventListener("pointermove", handlePointerEvent);
      svgElement.removeEventListener("pointerenter", handlePointerEvent);
      pointerUpdate.clear();
    };
  }, [svgRef, positionRef, itemPosition]);
  const anchorEl = React5.useMemo(() => ({
    getBoundingClientRect: () => ({
      x: positionRef.current.x,
      y: positionRef.current.y,
      top: positionRef.current.y,
      left: positionRef.current.x,
      right: positionRef.current.x,
      bottom: positionRef.current.y,
      width: 0,
      height: 0,
      toJSON: () => ""
    })
  }), [positionRef]);
  const isMouse = (pointerType == null ? void 0 : pointerType.pointerType) === "mouse" || isFineMainPointer;
  const isTouch = (pointerType == null ? void 0 : pointerType.pointerType) === "touch" || !isFineMainPointer;
  const modifiers = React5.useMemo(() => [
    {
      name: "offset",
      options: {
        offset: () => {
          if (isTouch) {
            return [0, 64];
          }
          return [0, 8];
        }
      }
    },
    ...!isMouse ? [{
      name: "flip",
      options: {
        fallbackPlacements: ["top-end", "top-start", "bottom-end", "bottom"]
      }
    }] : [],
    // Keep default behavior
    {
      name: "preventOverflow",
      options: {
        altAxis: true
      }
    }
  ], [isMouse, isTouch]);
  if (trigger === "none") {
    return null;
  }
  return (0, import_jsx_runtime5.jsx)(NoSsr_default, {
    children: isOpen && (0, import_jsx_runtime5.jsx)(ChartsTooltipRoot, _extends({}, other, {
      className: classes == null ? void 0 : classes.root,
      open: isOpen,
      placement: other.placement ?? position ?? (isMouse ? "right-start" : "top"),
      popperRef,
      anchorEl,
      modifiers,
      children
    }))
  });
}
true ? ChartsTooltipContainer.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Determine if the tooltip should be placed on the pointer location or on the node.
   * @default 'pointer'
   */
  anchor: import_prop_types4.default.oneOf(["node", "pointer"]),
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: import_prop_types4.default.oneOfType([HTMLElementType, import_prop_types4.default.object, import_prop_types4.default.func]),
  /**
   * Popper render function or node.
   */
  children: import_prop_types4.default.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types4.default.object,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: import_prop_types4.default.elementType,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  components: import_prop_types4.default.shape({
    Root: import_prop_types4.default.elementType
  }),
  /**
   * The props used for each slot inside the Popper.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  componentsProps: import_prop_types4.default.shape({
    root: import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: import_prop_types4.default.oneOfType([(props, propName) => {
    if (props[propName] == null) {
      return new Error(`Prop '${propName}' is required but wasn't specified`);
    }
    if (typeof props[propName] !== "object" || props[propName].nodeType !== 1) {
      return new Error(`Expected prop '${propName}' to be of type Element`);
    }
    return null;
  }, import_prop_types4.default.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: import_prop_types4.default.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: import_prop_types4.default.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: import_prop_types4.default.arrayOf(import_prop_types4.default.shape({
    data: import_prop_types4.default.object,
    effect: import_prop_types4.default.func,
    enabled: import_prop_types4.default.bool,
    fn: import_prop_types4.default.func,
    name: import_prop_types4.default.any,
    options: import_prop_types4.default.object,
    phase: import_prop_types4.default.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: import_prop_types4.default.arrayOf(import_prop_types4.default.string),
    requiresIfExists: import_prop_types4.default.arrayOf(import_prop_types4.default.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: import_prop_types4.default.bool,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: import_prop_types4.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: import_prop_types4.default.shape({
    modifiers: import_prop_types4.default.array,
    onFirstUpdate: import_prop_types4.default.func,
    placement: import_prop_types4.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: import_prop_types4.default.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.shape({
    current: import_prop_types4.default.shape({
      destroy: import_prop_types4.default.func.isRequired,
      forceUpdate: import_prop_types4.default.func.isRequired,
      setOptions: import_prop_types4.default.func.isRequired,
      state: import_prop_types4.default.shape({
        attributes: import_prop_types4.default.object.isRequired,
        elements: import_prop_types4.default.object.isRequired,
        modifiersData: import_prop_types4.default.object.isRequired,
        options: import_prop_types4.default.object.isRequired,
        orderedModifiers: import_prop_types4.default.arrayOf(import_prop_types4.default.object).isRequired,
        placement: import_prop_types4.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]).isRequired,
        rects: import_prop_types4.default.object.isRequired,
        reset: import_prop_types4.default.bool.isRequired,
        scrollParents: import_prop_types4.default.object.isRequired,
        strategy: import_prop_types4.default.oneOf(["absolute", "fixed"]).isRequired,
        styles: import_prop_types4.default.object.isRequired
      }).isRequired,
      update: import_prop_types4.default.func.isRequired
    })
  })]),
  /**
   * Determines the tooltip position relatively to the anchor.
   */
  position: import_prop_types4.default.oneOf(["bottom", "left", "right", "top"]),
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: import_prop_types4.default.object,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: import_prop_types4.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types4.default.oneOfType([import_prop_types4.default.arrayOf(import_prop_types4.default.oneOfType([import_prop_types4.default.func, import_prop_types4.default.object, import_prop_types4.default.bool])), import_prop_types4.default.func, import_prop_types4.default.object]),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: import_prop_types4.default.bool,
  /**
   * Select the kind of tooltip to display
   * - 'item': Shows data about the item below the mouse;
   * - 'axis': Shows values associated with the hovered x value;
   * - 'none': Does not display tooltip.
   * @default 'axis'
   */
  trigger: import_prop_types4.default.oneOf(["axis", "item", "none"])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsTooltip/ChartsTooltip.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
function ChartsTooltip(props) {
  const {
    classes: propClasses,
    trigger = "axis"
  } = props;
  const classes = useUtilityClasses(propClasses);
  return (0, import_jsx_runtime6.jsx)(ChartsTooltipContainer, _extends({}, props, {
    classes: propClasses,
    children: trigger === "axis" ? (0, import_jsx_runtime6.jsx)(ChartsAxisTooltipContent, {
      classes
    }) : (0, import_jsx_runtime6.jsx)(ChartsItemTooltipContent, {
      classes
    })
  }));
}
true ? ChartsTooltip.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Determine if the tooltip should be placed on the pointer location or on the node.
   * @default 'pointer'
   */
  anchor: import_prop_types5.default.oneOf(["node", "pointer"]),
  /**
   * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
   * or a function that returns either.
   * It's used to set the position of the popper.
   * The return value will passed as the reference object of the Popper instance.
   */
  anchorEl: import_prop_types5.default.oneOfType([HTMLElementType, import_prop_types5.default.object, import_prop_types5.default.func]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types5.default.object,
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: import_prop_types5.default.elementType,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   *
   * @deprecated use the `slots` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  components: import_prop_types5.default.shape({
    Root: import_prop_types5.default.elementType
  }),
  /**
   * The props used for each slot inside the Popper.
   *
   * @deprecated use the `slotProps` prop instead. This prop will be removed in a future major release. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
   * @default {}
   */
  componentsProps: import_prop_types5.default.shape({
    root: import_prop_types5.default.oneOfType([import_prop_types5.default.func, import_prop_types5.default.object])
  }),
  /**
   * An HTML element or function that returns one.
   * The `container` will have the portal children appended to it.
   *
   * You can also provide a callback, which is called in a React layout effect.
   * This lets you set the container from a ref, and also makes server-side rendering possible.
   *
   * By default, it uses the body of the top-level document object,
   * so it's simply `document.body` most of the time.
   */
  container: import_prop_types5.default.oneOfType([(props, propName) => {
    if (props[propName] == null) {
      return new Error(`Prop '${propName}' is required but wasn't specified`);
    }
    if (typeof props[propName] !== "object" || props[propName].nodeType !== 1) {
      return new Error(`Expected prop '${propName}' to be of type Element`);
    }
    return null;
  }, import_prop_types5.default.func]),
  /**
   * The `children` will be under the DOM hierarchy of the parent component.
   * @default false
   */
  disablePortal: import_prop_types5.default.bool,
  /**
   * Always keep the children in the DOM.
   * This prop can be useful in SEO situation or
   * when you want to maximize the responsiveness of the Popper.
   * @default false
   */
  keepMounted: import_prop_types5.default.bool,
  /**
   * Popper.js is based on a "plugin-like" architecture,
   * most of its features are fully encapsulated "modifiers".
   *
   * A modifier is a function that is called each time Popper.js needs to
   * compute the position of the popper.
   * For this reason, modifiers should be very performant to avoid bottlenecks.
   * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
   */
  modifiers: import_prop_types5.default.arrayOf(import_prop_types5.default.shape({
    data: import_prop_types5.default.object,
    effect: import_prop_types5.default.func,
    enabled: import_prop_types5.default.bool,
    fn: import_prop_types5.default.func,
    name: import_prop_types5.default.any,
    options: import_prop_types5.default.object,
    phase: import_prop_types5.default.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
    requires: import_prop_types5.default.arrayOf(import_prop_types5.default.string),
    requiresIfExists: import_prop_types5.default.arrayOf(import_prop_types5.default.string)
  })),
  /**
   * If `true`, the component is shown.
   */
  open: import_prop_types5.default.bool,
  /**
   * Popper placement.
   * @default 'bottom'
   */
  placement: import_prop_types5.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
  /**
   * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
   * @default {}
   */
  popperOptions: import_prop_types5.default.shape({
    modifiers: import_prop_types5.default.array,
    onFirstUpdate: import_prop_types5.default.func,
    placement: import_prop_types5.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    strategy: import_prop_types5.default.oneOf(["absolute", "fixed"])
  }),
  /**
   * A ref that points to the used popper instance.
   */
  popperRef: import_prop_types5.default.oneOfType([import_prop_types5.default.func, import_prop_types5.default.shape({
    current: import_prop_types5.default.shape({
      destroy: import_prop_types5.default.func.isRequired,
      forceUpdate: import_prop_types5.default.func.isRequired,
      setOptions: import_prop_types5.default.func.isRequired,
      state: import_prop_types5.default.shape({
        attributes: import_prop_types5.default.object.isRequired,
        elements: import_prop_types5.default.object.isRequired,
        modifiersData: import_prop_types5.default.object.isRequired,
        options: import_prop_types5.default.object.isRequired,
        orderedModifiers: import_prop_types5.default.arrayOf(import_prop_types5.default.object).isRequired,
        placement: import_prop_types5.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]).isRequired,
        rects: import_prop_types5.default.object.isRequired,
        reset: import_prop_types5.default.bool.isRequired,
        scrollParents: import_prop_types5.default.object.isRequired,
        strategy: import_prop_types5.default.oneOf(["absolute", "fixed"]).isRequired,
        styles: import_prop_types5.default.object.isRequired
      }).isRequired,
      update: import_prop_types5.default.func.isRequired
    })
  })]),
  /**
   * Determines the tooltip position relatively to the anchor.
   */
  position: import_prop_types5.default.oneOf(["bottom", "left", "right", "top"]),
  /**
   * The props used for each slot inside the Popper.
   * @default {}
   */
  slotProps: import_prop_types5.default.object,
  /**
   * The components used for each slot inside the Popper.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: import_prop_types5.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types5.default.oneOfType([import_prop_types5.default.arrayOf(import_prop_types5.default.oneOfType([import_prop_types5.default.func, import_prop_types5.default.object, import_prop_types5.default.bool])), import_prop_types5.default.func, import_prop_types5.default.object]),
  /**
   * Help supporting a react-transition-group/Transition component.
   * @default false
   */
  transition: import_prop_types5.default.bool,
  /**
   * Select the kind of tooltip to display
   * - 'item': Shows data about the item below the mouse;
   * - 'axis': Shows values associated with the hovered x value;
   * - 'none': Does not display tooltip.
   * @default 'axis'
   */
  trigger: import_prop_types5.default.oneOf(["axis", "item", "none"])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsLegend/ChartsLegend.js
var React8 = __toESM(require_react(), 1);
var import_prop_types7 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsLegend/onClickContextBuilder.js
var seriesContextBuilder = (context) => ({
  type: "series",
  color: context.color,
  label: context.label,
  seriesId: context.seriesId,
  itemId: context.itemId
});

// node_modules/@mui/x-charts/esm/ChartsLegend/chartsLegendClasses.js
function getLegendUtilityClass(slot) {
  return generateUtilityClass("MuiChartsLegend", slot);
}
var useUtilityClasses3 = (props) => {
  const {
    classes,
    direction
  } = props;
  const slots = {
    root: ["root", direction],
    item: ["item"],
    mark: ["mark"],
    label: ["label"],
    series: ["series"]
  };
  return composeClasses(slots, getLegendUtilityClass, classes);
};
var legendClasses = generateUtilityClasses("MuiChartsLegend", ["root", "item", "series", "mark", "label", "vertical", "horizontal"]);

// node_modules/@mui/x-charts/esm/internals/consumeSlots.js
var React6 = __toESM(require_react(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var _excluded3 = ["slots", "slotProps"];
var _excluded22 = ["ownerState"];
var consumeSlots = (name, slotPropName, options, InComponent) => {
  function ConsumeSlotsInternal(props, ref) {
    var _a;
    const themedProps = useThemeProps({
      props,
      // eslint-disable-next-line material-ui/mui-name-matches-component-name
      name
    });
    const defaultProps = typeof options.defaultProps === "function" ? options.defaultProps(themedProps) : options.defaultProps ?? {};
    const defaultizedProps = resolveProps(defaultProps, themedProps);
    const _ref = defaultizedProps, {
      slots,
      slotProps
    } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded3);
    const theme = useTheme();
    const classes = (_a = options.classesResolver) == null ? void 0 : _a.call(options, defaultizedProps, theme);
    const Component = (slots == null ? void 0 : slots[slotPropName]) ?? InComponent;
    const propagateSlots = options.propagateSlots && !(slots == null ? void 0 : slots[slotPropName]);
    const _useSlotProps = useSlotProps_default({
      elementType: Component,
      externalSlotProps: slotProps == null ? void 0 : slotProps[slotPropName],
      additionalProps: _extends({}, other, {
        classes
      }, propagateSlots && {
        slots,
        slotProps
      }),
      ownerState: {}
    }), originalOutProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded22);
    const outProps = _extends({}, originalOutProps);
    for (const prop of options.omitProps ?? []) {
      delete outProps[prop];
    }
    if (true) {
      Component.displayName = `${name}.slots.${slotPropName}`;
    }
    return (0, import_jsx_runtime7.jsx)(Component, _extends({}, outProps, {
      ref
    }));
  }
  return React6.forwardRef(ConsumeSlotsInternal);
};
if (true) consumeSlots.displayName = "consumeSlots";

// node_modules/@mui/x-charts/esm/ChartsLabel/ChartsLabel.js
var React7 = __toESM(require_react(), 1);
var import_prop_types6 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsLabel/labelClasses.js
function getLabelUtilityClass(slot) {
  return generateUtilityClass("MuiChartsLabel", slot);
}
var labelClasses = generateUtilityClasses("MuiChartsLabel", ["root"]);
var useUtilityClasses4 = (props) => {
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getLabelUtilityClass, props.classes);
};

// node_modules/@mui/x-charts/esm/ChartsLabel/ChartsLabel.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var _excluded4 = ["children", "className", "classes"];
var ChartsLabel = consumeThemeProps("MuiChartsLabel", {
  classesResolver: useUtilityClasses4
}, function ChartsLabel2(props, ref) {
  const {
    children,
    className,
    classes
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded4);
  return (0, import_jsx_runtime8.jsx)("span", _extends({
    className: clsx_default(classes == null ? void 0 : classes.root, className),
    ref
  }, other, {
    children
  }));
});
true ? ChartsLabel.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types6.default.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types6.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsLegend/ChartsLegend.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var _excluded5 = ["direction", "onItemClick", "className", "classes"];
var RootElement = styled_default("ul", {
  name: "MuiChartsLegend",
  slot: "Root"
})(({
  ownerState,
  theme
}) => _extends({}, theme.typography.caption, {
  color: (theme.vars || theme).palette.text.primary,
  lineHeight: "100%",
  display: "flex",
  flexDirection: ownerState.direction === "vertical" ? "column" : "row",
  alignItems: ownerState.direction === "vertical" ? void 0 : "center",
  flexShrink: 0,
  gap: theme.spacing(2),
  listStyleType: "none",
  paddingInlineStart: 0,
  marginBlock: theme.spacing(1),
  marginInline: theme.spacing(1),
  flexWrap: "wrap",
  li: {
    display: ownerState.direction === "horizontal" ? "inline-flex" : void 0
  },
  [`button.${legendClasses.series}`]: {
    // Reset button styles
    background: "none",
    border: "none",
    padding: 0,
    fontFamily: "inherit",
    fontWeight: "inherit",
    fontSize: "inherit",
    letterSpacing: "inherit",
    color: "inherit"
  },
  [`& .${legendClasses.series}`]: {
    display: ownerState.direction === "vertical" ? "flex" : "inline-flex",
    alignItems: "center",
    gap: theme.spacing(1)
  },
  gridArea: "legend"
}));
var ChartsLegend = consumeSlots("MuiChartsLegend", "legend", {
  defaultProps: {
    direction: "horizontal"
  },
  // @ts-expect-error position is used only in the slots, but it is passed to the SVG wrapper.
  // We omit it here to avoid passing to slots.
  omitProps: ["position"],
  classesResolver: useUtilityClasses3
}, React8.forwardRef(function ChartsLegend2(props, ref) {
  const data = useLegend();
  const {
    onItemClick,
    className,
    classes
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded5);
  if (data.items.length === 0) {
    return null;
  }
  const Element = onItemClick ? "button" : "div";
  return (0, import_jsx_runtime9.jsx)(RootElement, _extends({
    className: clsx_default(classes == null ? void 0 : classes.root, className),
    ref
  }, other, {
    ownerState: props,
    children: data.items.map((item, i) => {
      return (0, import_jsx_runtime9.jsx)("li", {
        className: classes == null ? void 0 : classes.item,
        "data-series": item.id,
        children: (0, import_jsx_runtime9.jsxs)(Element, {
          className: classes == null ? void 0 : classes.series,
          role: onItemClick ? "button" : void 0,
          type: onItemClick ? "button" : void 0,
          onClick: onItemClick ? (
            // @ts-ignore onClick is only attached to a button
            (event) => onItemClick(event, seriesContextBuilder(item), i)
          ) : void 0,
          children: [(0, import_jsx_runtime9.jsx)(ChartsLabelMark, {
            className: classes == null ? void 0 : classes.mark,
            color: item.color,
            type: item.markType
          }), (0, import_jsx_runtime9.jsx)(ChartsLabel, {
            className: classes == null ? void 0 : classes.label,
            children: item.label
          })]
        })
      }, item.id);
    })
  }));
}));
if (true) ChartsLegend.displayName = "ChartsLegend";
true ? ChartsLegend.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types7.default.object,
  className: import_prop_types7.default.string,
  /**
   * The direction of the legend layout.
   * The default depends on the chart.
   */
  direction: import_prop_types7.default.oneOf(["horizontal", "vertical"]),
  /**
   * Callback fired when a legend item is clicked.
   * @param {React.MouseEvent<HTMLButtonElement, MouseEvent>} event The click event.
   * @param {SeriesLegendItemContext} legendItem The legend item data.
   * @param {number} index The index of the clicked legend item.
   */
  onItemClick: import_prop_types7.default.func,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types7.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types7.default.object,
  sx: import_prop_types7.default.oneOfType([import_prop_types7.default.arrayOf(import_prop_types7.default.oneOfType([import_prop_types7.default.func, import_prop_types7.default.object, import_prop_types7.default.bool])), import_prop_types7.default.func, import_prop_types7.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsLegend/ContinuousColorLegend.js
var React10 = __toESM(require_react(), 1);
var import_prop_types9 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsLegend/useAxis.js
function useAxis({
  axisDirection,
  axisId
}) {
  const {
    xAxis,
    xAxisIds
  } = useXAxes();
  const {
    yAxis,
    yAxisIds
  } = useYAxes();
  const {
    zAxis,
    zAxisIds
  } = useZAxes();
  switch (axisDirection) {
    case "x": {
      const id = typeof axisId === "string" ? axisId : xAxisIds[axisId ?? 0];
      return xAxis[id];
    }
    case "y": {
      const id = typeof axisId === "string" ? axisId : yAxisIds[axisId ?? 0];
      return yAxis[id];
    }
    case "z":
    default: {
      const id = typeof axisId === "string" ? axisId : zAxisIds[axisId ?? 0];
      return zAxis[id];
    }
  }
}

// node_modules/@mui/x-charts/esm/ChartsLabel/ChartsLabelGradient.js
var React9 = __toESM(require_react(), 1);
var import_prop_types8 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsLabel/labelGradientClasses.js
function getLabelGradientUtilityClass(slot) {
  return generateUtilityClass("MuiChartsLabelGradient", slot);
}
var labelGradientClasses = generateUtilityClasses("MuiChartsLabelGradient", ["root", "vertical", "horizontal", "mask", "fill"]);
var useUtilityClasses5 = (props) => {
  const {
    direction
  } = props;
  const slots = {
    root: ["root", direction],
    mask: ["mask"],
    fill: ["fill"]
  };
  return composeClasses(slots, getLabelGradientUtilityClass, props.classes);
};

// node_modules/@mui/x-charts/esm/ChartsLabel/ChartsLabelGradient.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var _excluded6 = ["gradientId", "direction", "classes", "className", "rotate", "reverse", "thickness"];
var getRotation = (direction, reverse, rotate, isRtl) => {
  const angle = (direction === "vertical" ? -90 : 0) + (rotate ? 90 : 0) + (reverse ? 180 : 0);
  if (isRtl && direction !== "vertical") {
    return angle + 180;
  }
  return angle;
};
var Root2 = styled_default("div", {
  name: "MuiChartsLabelGradient",
  slot: "Root"
})(({
  ownerState
}) => {
  const rotation = getRotation(ownerState.direction, ownerState.reverse, ownerState.rotate, ownerState.isRtl);
  return {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    [`.${labelGradientClasses.mask}`]: {
      borderRadius: 2,
      overflow: "hidden"
    },
    [`&.${labelGradientClasses.horizontal}`]: {
      width: "100%",
      [`.${labelGradientClasses.mask}`]: {
        height: ownerState.thickness,
        width: "100%"
      }
    },
    [`&.${labelGradientClasses.vertical}`]: {
      height: "100%",
      [`.${labelGradientClasses.mask}`]: {
        width: ownerState.thickness,
        height: "100%",
        "> svg": {
          height: "100%"
        }
      }
    },
    svg: {
      transform: `rotate(${rotation}deg)`,
      display: "block"
    }
  };
});
var ChartsLabelGradient = consumeThemeProps("MuiChartsLabelGradient", {
  defaultProps: {
    direction: "horizontal",
    thickness: 12
  },
  classesResolver: useUtilityClasses5
}, function ChartsLabelGradient2(props, ref) {
  const {
    gradientId,
    classes,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded6);
  const isRtl = useRtl();
  return (0, import_jsx_runtime10.jsx)(Root2, _extends({
    className: clsx_default(classes == null ? void 0 : classes.root, className),
    ownerState: _extends({}, props, {
      isRtl
    }),
    "aria-hidden": "true",
    ref
  }, other, {
    children: (0, import_jsx_runtime10.jsx)("div", {
      className: classes == null ? void 0 : classes.mask,
      children: (0, import_jsx_runtime10.jsx)("svg", {
        viewBox: "0 0 24 24",
        children: (0, import_jsx_runtime10.jsx)("rect", {
          className: classes == null ? void 0 : classes.fill,
          width: "24",
          height: "24",
          fill: `url(#${gradientId})`
        })
      })
    })
  }));
});
true ? ChartsLabelGradient.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types8.default.object,
  /**
   * The direction of the gradient.
   * @default 'horizontal'
   */
  direction: import_prop_types8.default.oneOf(["vertical", "horizontal"]),
  /**
   * A unique identifier for the gradient.
   * The `gradientId` will be used as `fill="url(#gradientId)"`.
   */
  gradientId: import_prop_types8.default.string.isRequired,
  /**
   * If `true`, the gradient will be reversed.
   */
  reverse: import_prop_types8.default.bool,
  /**
   * If provided, the gradient will be rotated by 90deg.
   * Useful for linear gradients that are not in the correct orientation.
   */
  rotate: import_prop_types8.default.bool,
  /**
   * The thickness of the gradient
   * @default 12
   */
  thickness: import_prop_types8.default.number
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsLegend/continuousColorLegendClasses.js
function getLegendUtilityClass2(slot) {
  return generateUtilityClass("MuiContinuousColorLegend", slot);
}
var useUtilityClasses6 = (props) => {
  const {
    classes,
    direction,
    labelPosition
  } = props;
  const slots = {
    root: ["root", direction, labelPosition],
    minLabel: ["minLabel"],
    maxLabel: ["maxLabel"],
    gradient: ["gradient"],
    mark: ["mark"],
    label: ["label"]
  };
  return composeClasses(slots, getLegendUtilityClass2, classes);
};
var continuousColorLegendClasses = generateUtilityClasses("MuiContinuousColorLegend", ["root", "minLabel", "maxLabel", "gradient", "vertical", "horizontal", "start", "end", "extremes", "label"]);

// node_modules/@mui/x-charts/esm/ChartsLegend/ContinuousColorLegend.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var _excluded7 = ["minLabel", "maxLabel", "direction", "axisDirection", "axisId", "rotateGradient", "reverse", "classes", "className", "gradientId", "labelPosition", "thickness"];
var templateAreas = (reverse) => {
  const startLabel = reverse ? "max-label" : "min-label";
  const endLabel = reverse ? "min-label" : "max-label";
  return {
    row: {
      start: `
    '${startLabel} . ${endLabel}'
    'gradient gradient gradient'
  `,
      end: `
      'gradient gradient gradient'
      '${startLabel} . ${endLabel}'
    `,
      extremes: `
      '${startLabel} gradient ${endLabel}'
    `
    },
    column: {
      start: `
      '${endLabel} gradient'
      '. gradient'
      '${startLabel} gradient'
    `,
      end: `
      'gradient ${endLabel}'
      'gradient .'
      'gradient ${startLabel}'
    `,
      extremes: `
      '${endLabel}'
      'gradient'
      '${startLabel}'
    `
    }
  };
};
var RootElement2 = styled_default("ul", {
  name: "MuiContinuousColorLegend",
  slot: "Root"
})(({
  theme,
  ownerState
}) => _extends({}, theme.typography.caption, {
  color: (theme.vars || theme).palette.text.primary,
  lineHeight: "100%",
  display: "grid",
  flexShrink: 0,
  gap: theme.spacing(0.5),
  listStyleType: "none",
  paddingInlineStart: 0,
  marginBlock: theme.spacing(1),
  marginInline: theme.spacing(1),
  gridArea: "legend",
  [`&.${continuousColorLegendClasses.horizontal}`]: {
    gridTemplateRows: "min-content min-content",
    gridTemplateColumns: "min-content auto min-content",
    [`&.${continuousColorLegendClasses.start}`]: {
      gridTemplateAreas: templateAreas(ownerState.reverse).row.start
    },
    [`&.${continuousColorLegendClasses.end}`]: {
      gridTemplateAreas: templateAreas(ownerState.reverse).row.end
    },
    [`&.${continuousColorLegendClasses.extremes}`]: {
      gridTemplateAreas: templateAreas(ownerState.reverse).row.extremes,
      gridTemplateRows: "min-content",
      alignItems: "center"
    }
  },
  [`&.${continuousColorLegendClasses.vertical}`]: {
    gridTemplateRows: "min-content auto min-content",
    gridTemplateColumns: "min-content min-content",
    [`&.${continuousColorLegendClasses.start}`]: {
      gridTemplateAreas: templateAreas(ownerState.reverse).column.start,
      [`.${continuousColorLegendClasses.maxLabel}, .${continuousColorLegendClasses.minLabel}`]: {
        justifySelf: "end"
      }
    },
    [`&.${continuousColorLegendClasses.end}`]: {
      gridTemplateAreas: templateAreas(ownerState.reverse).column.end,
      [`.${continuousColorLegendClasses.maxLabel}, .${continuousColorLegendClasses.minLabel}`]: {
        justifySelf: "start"
      }
    },
    [`&.${continuousColorLegendClasses.extremes}`]: {
      gridTemplateAreas: templateAreas(ownerState.reverse).column.extremes,
      gridTemplateColumns: "min-content",
      [`.${continuousColorLegendClasses.maxLabel}, .${continuousColorLegendClasses.minLabel}`]: {
        justifySelf: "center"
      }
    }
  },
  [`.${continuousColorLegendClasses.gradient}`]: {
    gridArea: "gradient"
  },
  [`.${continuousColorLegendClasses.maxLabel}`]: {
    gridArea: "max-label"
  },
  [`.${continuousColorLegendClasses.minLabel}`]: {
    gridArea: "min-label"
  }
}));
var getText = (label, value, formattedValue) => {
  if (typeof label === "string") {
    return label;
  }
  return (label == null ? void 0 : label({
    value,
    formattedValue
  })) ?? formattedValue;
};
var isZAxis = (axis) => axis.scale === void 0;
var ContinuousColorLegend = consumeThemeProps("MuiContinuousColorLegend", {
  defaultProps: {
    direction: "horizontal",
    labelPosition: "end",
    axisDirection: "z"
  },
  classesResolver: useUtilityClasses6
}, function ContinuousColorLegend2(props, ref) {
  const {
    minLabel,
    maxLabel,
    direction,
    axisDirection,
    axisId,
    rotateGradient,
    reverse,
    classes,
    className,
    gradientId,
    thickness
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded7);
  const generateGradientId = useChartGradientIdObjectBoundBuilder();
  const axisItem = useAxis({
    axisDirection,
    axisId
  });
  const colorMap = axisItem == null ? void 0 : axisItem.colorMap;
  if (!colorMap || !colorMap.type || colorMap.type !== "continuous") {
    return null;
  }
  const minValue = colorMap.min ?? 0;
  const maxValue = colorMap.max ?? 100;
  const valueFormatter = isZAxis(axisItem) ? void 0 : axisItem.valueFormatter;
  const formattedMin = valueFormatter ? valueFormatter(minValue, {
    location: "legend"
  }) : minValue.toLocaleString();
  const formattedMax = valueFormatter ? valueFormatter(maxValue, {
    location: "legend"
  }) : maxValue.toLocaleString();
  const minText = getText(minLabel, minValue, formattedMin);
  const maxText = getText(maxLabel, maxValue, formattedMax);
  const minComponent = (0, import_jsx_runtime11.jsx)("li", {
    className: classes == null ? void 0 : classes.minLabel,
    children: (0, import_jsx_runtime11.jsx)(ChartsLabel, {
      className: classes == null ? void 0 : classes.label,
      children: minText
    })
  });
  const maxComponent = (0, import_jsx_runtime11.jsx)("li", {
    className: classes == null ? void 0 : classes.maxLabel,
    children: (0, import_jsx_runtime11.jsx)(ChartsLabel, {
      className: classes == null ? void 0 : classes.label,
      children: maxText
    })
  });
  return (0, import_jsx_runtime11.jsxs)(RootElement2, _extends({
    className: clsx_default(classes == null ? void 0 : classes.root, className),
    ref
  }, other, {
    ownerState: props,
    children: [reverse ? maxComponent : minComponent, (0, import_jsx_runtime11.jsx)("li", {
      className: classes == null ? void 0 : classes.gradient,
      children: (0, import_jsx_runtime11.jsx)(ChartsLabelGradient, {
        direction,
        rotate: rotateGradient,
        reverse,
        thickness,
        gradientId: gradientId ?? generateGradientId(axisItem.id)
      })
    }), reverse ? minComponent : maxComponent]
  }));
});
true ? ContinuousColorLegend.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The axis direction containing the color configuration to represent.
   * @default 'z'
   */
  axisDirection: import_prop_types9.default.oneOf(["x", "y", "z"]),
  /**
   * The id of the axis item with the color configuration to represent.
   * @default The first axis item.
   */
  axisId: import_prop_types9.default.oneOfType([import_prop_types9.default.number, import_prop_types9.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types9.default.object,
  className: import_prop_types9.default.string,
  /**
   * The direction of the legend layout.
   * @default 'horizontal'
   */
  direction: import_prop_types9.default.oneOf(["horizontal", "vertical"]),
  /**
   * The id for the gradient to use.
   * If not provided, it will use the generated gradient from the axis configuration.
   * The `gradientId` will be used as `fill="url(#gradientId)"`.
   * @default auto-generated id
   */
  gradientId: import_prop_types9.default.string,
  /**
   * Where to position the labels relative to the gradient.
   * @default 'end'
   */
  labelPosition: import_prop_types9.default.oneOf(["start", "end", "extremes"]),
  /**
   * The label to display at the maximum side of the gradient.
   * Can either be a string, or a function.
   * If not defined, the formatted maximal value is display.
   * @default formattedValue
   */
  maxLabel: import_prop_types9.default.oneOfType([import_prop_types9.default.func, import_prop_types9.default.string]),
  /**
   * The label to display at the minimum side of the gradient.
   * Can either be a string, or a function.
   * @default formattedValue
   */
  minLabel: import_prop_types9.default.oneOfType([import_prop_types9.default.func, import_prop_types9.default.string]),
  /**
   * If `true`, the gradient and labels will be reversed.
   * @default false
   */
  reverse: import_prop_types9.default.bool,
  /**
   * If provided, the gradient will be rotated by 90deg.
   * Useful for linear gradients that are not in the correct orientation.
   */
  rotateGradient: import_prop_types9.default.bool,
  /**
   * The thickness of the gradient
   * @default 12
   */
  thickness: import_prop_types9.default.number,
  sx: import_prop_types9.default.oneOfType([import_prop_types9.default.arrayOf(import_prop_types9.default.oneOfType([import_prop_types9.default.func, import_prop_types9.default.object, import_prop_types9.default.bool])), import_prop_types9.default.func, import_prop_types9.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsLegend/PiecewiseColorLegend.js
var React11 = __toESM(require_react(), 1);
var import_prop_types10 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/ChartsLegend/piecewiseColorLegendClasses.js
function getLegendUtilityClass3(slot) {
  return generateUtilityClass("MuiPiecewiseColorLegendClasses", slot);
}
var useUtilityClasses7 = (props) => {
  const {
    classes,
    direction,
    labelPosition
  } = props;
  const slots = {
    root: ["root", direction, labelPosition == null ? void 0 : labelPosition.replaceAll(/-(\w)/g, (match) => match[1].toUpperCase())],
    minLabel: ["minLabel"],
    maxLabel: ["maxLabel"],
    item: ["item"],
    mark: ["mark"],
    label: ["label"]
  };
  return composeClasses(slots, getLegendUtilityClass3, classes);
};
var piecewiseColorLegendClasses = generateUtilityClasses("MuiPiecewiseColorLegendClasses", ["root", "minLabel", "maxLabel", "item", "vertical", "horizontal", "start", "end", "extremes", "inlineStart", "inlineEnd", "mark", "label"]);

// node_modules/@mui/x-charts/esm/ChartsLegend/piecewiseColorDefaultLabelFormatter.js
function piecewiseColorDefaultLabelFormatter(params) {
  if (params.min === null) {
    return `<${params.formattedMax}`;
  }
  if (params.max === null) {
    return `>${params.formattedMin}`;
  }
  return `${params.formattedMin}-${params.formattedMax}`;
}

// node_modules/@mui/x-charts/esm/ChartsLegend/PiecewiseColorLegend.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var _excluded8 = ["direction", "classes", "className", "markType", "labelPosition", "axisDirection", "axisId", "labelFormatter", "onItemClick"];
var RootElement3 = styled_default("ul", {
  name: "MuiPiecewiseColorLegend",
  slot: "Root"
})(({
  theme,
  ownerState
}) => {
  const classes = piecewiseColorLegendClasses;
  return _extends({}, theme.typography.caption, {
    color: (theme.vars || theme).palette.text.primary,
    lineHeight: "100%",
    display: "flex",
    flexDirection: ownerState.direction === "vertical" ? "column" : "row",
    flexShrink: 0,
    gap: theme.spacing(0.5),
    listStyleType: "none",
    paddingInlineStart: 0,
    marginBlock: theme.spacing(1),
    marginInline: theme.spacing(1),
    width: "fit-content",
    gridArea: "legend",
    [`button.${classes.item}`]: {
      // Reset button styles
      background: "none",
      border: "none",
      padding: 0,
      cursor: ownerState.onItemClick ? "pointer" : "unset",
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      letterSpacing: "inherit",
      color: "inherit"
    },
    [`.${classes.item}`]: {
      display: "flex",
      gap: theme.spacing(0.5)
    },
    [`li :not(.${classes.minLabel}, .${classes.maxLabel}) .${classes == null ? void 0 : classes.mark}`]: {
      alignSelf: "center"
    },
    [`&.${classes.start}`]: {
      alignItems: "end"
    },
    [`&.${classes.end}`]: {
      alignItems: "start"
    },
    [`&.${classes.horizontal}`]: {
      alignItems: "center",
      [`.${classes.item}`]: {
        flexDirection: "column"
      },
      [`&.${classes.inlineStart}, &.${classes.inlineEnd}`]: {
        gap: theme.spacing(1.5),
        flexWrap: "wrap",
        [`.${classes.item}`]: {
          flexDirection: "row"
        }
      },
      [`&.${classes.start}`]: {
        alignItems: "end"
      },
      [`&.${classes.end}`]: {
        alignItems: "start"
      },
      [`.${classes.minLabel}`]: {
        alignItems: "end"
      },
      [`&.${classes.extremes}`]: {
        [`.${classes.minLabel}, .${classes.maxLabel}`]: {
          alignItems: "center",
          display: "flex",
          flexDirection: "row"
        }
      }
    },
    [`&.${classes.vertical}`]: {
      [`.${classes.item}`]: {
        flexDirection: "row",
        alignItems: "center"
      },
      [`&.${classes.start}, &.${classes.inlineStart}`]: {
        alignItems: "end"
      },
      [`&.${classes.end}, &.${classes.inlineEnd}`]: {
        alignItems: "start"
      },
      [`&.${classes.extremes}`]: {
        alignItems: "center",
        [`.${classes.minLabel}, .${classes.maxLabel}`]: {
          alignItems: "center",
          display: "flex",
          flexDirection: "column"
        }
      }
    }
  });
});
var PiecewiseColorLegend = consumeThemeProps("MuiPiecewiseColorLegend", {
  defaultProps: {
    direction: "horizontal",
    labelPosition: "extremes",
    labelFormatter: piecewiseColorDefaultLabelFormatter
  },
  classesResolver: useUtilityClasses7
}, function PiecewiseColorLegend2(props, ref) {
  const {
    direction,
    classes,
    className,
    markType,
    labelPosition,
    axisDirection,
    axisId,
    labelFormatter,
    onItemClick
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded8);
  const isVertical = direction === "vertical";
  const isReverse = isVertical;
  const axisItem = useAxis({
    axisDirection,
    axisId
  });
  const colorMap = axisItem == null ? void 0 : axisItem.colorMap;
  if (!colorMap || !colorMap.type || colorMap.type !== "piecewise") {
    return null;
  }
  const valueFormatter = (v) => {
    var _a;
    return ((_a = axisItem.valueFormatter) == null ? void 0 : _a.call(axisItem, v, {
      location: "legend"
    })) ?? v.toLocaleString();
  };
  const formattedLabels = colorMap.thresholds.map(valueFormatter);
  const startClass = isReverse ? classes == null ? void 0 : classes.maxLabel : classes == null ? void 0 : classes.minLabel;
  const endClass = isReverse ? classes == null ? void 0 : classes.minLabel : classes == null ? void 0 : classes.maxLabel;
  const colors = colorMap.colors.map((color, colorIndex) => ({
    color,
    colorIndex
  }));
  const orderedColors = isReverse ? colors.reverse() : colors;
  const isStart = labelPosition === "start";
  const isEnd = labelPosition === "end";
  const isExtremes = labelPosition === "extremes";
  const isInlineStart = labelPosition === "inline-start";
  const isInlineEnd = labelPosition === "inline-end";
  return (0, import_jsx_runtime12.jsx)(RootElement3, _extends({
    className: clsx_default(classes == null ? void 0 : classes.root, className),
    ref
  }, other, {
    ownerState: props,
    children: orderedColors.map(({
      color,
      colorIndex
    }, index) => {
      const isFirst = index === 0;
      const isLast = index === colorMap.colors.length - 1;
      const isFirstColor = colorIndex === 0;
      const isLastColor = colorIndex === colorMap.colors.length - 1;
      const data = _extends({
        index: colorIndex,
        length: formattedLabels.length
      }, isFirstColor ? {
        min: null,
        formattedMin: null
      } : {
        min: colorMap.thresholds[colorIndex - 1],
        formattedMin: formattedLabels[colorIndex - 1]
      }, isLastColor ? {
        max: null,
        formattedMax: null
      } : {
        max: colorMap.thresholds[colorIndex],
        formattedMax: formattedLabels[colorIndex]
      });
      const label = labelFormatter == null ? void 0 : labelFormatter(data);
      if (label === null || label === void 0) {
        return null;
      }
      const isTextBefore = isStart || isExtremes && isFirst || isInlineStart;
      const isTextAfter = isEnd || isExtremes && isLast || isInlineEnd;
      const clickObject = {
        type: "piecewiseColor",
        color,
        label,
        minValue: data.min,
        maxValue: data.max
      };
      const Element = onItemClick ? "button" : "div";
      return (0, import_jsx_runtime12.jsx)("li", {
        children: (0, import_jsx_runtime12.jsxs)(Element, {
          role: onItemClick ? "button" : void 0,
          type: onItemClick ? "button" : void 0,
          onClick: (
            // @ts-ignore onClick is only attached to a button
            onItemClick ? (event) => onItemClick(event, clickObject, index) : void 0
          ),
          className: clsx_default(classes == null ? void 0 : classes.item, index === 0 && `${startClass}`, index === orderedColors.length - 1 && `${endClass}`),
          children: [isTextBefore && (0, import_jsx_runtime12.jsx)(ChartsLabel, {
            className: classes == null ? void 0 : classes.label,
            children: label
          }), (0, import_jsx_runtime12.jsx)(ChartsLabelMark, {
            className: classes == null ? void 0 : classes.mark,
            type: markType,
            color
          }), isTextAfter && (0, import_jsx_runtime12.jsx)(ChartsLabel, {
            className: classes == null ? void 0 : classes.label,
            children: label
          })]
        })
      }, colorIndex);
    })
  }));
});
true ? PiecewiseColorLegend.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The axis direction containing the color configuration to represent.
   * @default 'z'
   */
  axisDirection: import_prop_types10.default.oneOf(["x", "y", "z"]),
  /**
   * The id of the axis item with the color configuration to represent.
   * @default The first axis item.
   */
  axisId: import_prop_types10.default.oneOfType([import_prop_types10.default.number, import_prop_types10.default.string]),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types10.default.object,
  className: import_prop_types10.default.string,
  /**
   * The direction of the legend layout.
   * @default 'horizontal'
   */
  direction: import_prop_types10.default.oneOf(["horizontal", "vertical"]),
  /**
   * Format the legend labels.
   * @param {PiecewiseLabelFormatterParams} params The bound of the piece to format.
   * @returns {string|null} The displayed label, `''` to skip the label but show the color mark, or `null` to skip it entirely.
   */
  labelFormatter: import_prop_types10.default.func,
  /**
   * Where to position the labels relative to the gradient.
   * @default 'extremes'
   */
  labelPosition: import_prop_types10.default.oneOf(["start", "end", "extremes", "inline-start", "inline-end"]),
  /**
   * The type of the mark.
   * @default 'square'
   */
  markType: import_prop_types10.default.oneOf(["square", "circle", "line"]),
  /**
   * Callback fired when a legend item is clicked.
   * @param {React.MouseEvent<HTMLButtonElement, MouseEvent>} event The click event.
   * @param {PiecewiseColorLegendItemContext} legendItem The legend item data.
   * @param {number} index The index of the clicked legend item.
   */
  onItemClick: import_prop_types10.default.func,
  sx: import_prop_types10.default.oneOfType([import_prop_types10.default.arrayOf(import_prop_types10.default.oneOfType([import_prop_types10.default.func, import_prop_types10.default.object, import_prop_types10.default.bool])), import_prop_types10.default.func, import_prop_types10.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/PieChart/PiePlot.js
var import_prop_types15 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/PieChart/PieArcPlot.js
var React16 = __toESM(require_react(), 1);
var import_prop_types12 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/hooks/useFocusedItem.js
var React12 = __toESM(require_react(), 1);
function useFocusedItem() {
  const store = useStore();
  const focusedSeriesType = useSelector(store, selectorChartsFocusedSeriesType);
  const focusedSeriesId = useSelector(store, selectorChartsFocusedSeriesId);
  const focusedDataIndex = useSelector(store, selectorChartsFocusedDataIndex);
  return React12.useMemo(() => focusedSeriesType === void 0 || focusedSeriesId === void 0 || focusedDataIndex === void 0 ? null : {
    seriesType: focusedSeriesType,
    seriesId: focusedSeriesId,
    dataIndex: focusedDataIndex
  }, [focusedSeriesType, focusedSeriesId, focusedDataIndex]);
}

// node_modules/@mui/x-charts/esm/PieChart/PieArc.js
var React14 = __toESM(require_react(), 1);
var import_prop_types11 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/hooks/useInteractionItemProps.js
var React13 = __toESM(require_react(), 1);
function onPointerDown(event) {
  if ("hasPointerCapture" in event.currentTarget && event.currentTarget.hasPointerCapture(event.pointerId)) {
    event.currentTarget.releasePointerCapture(event.pointerId);
  }
}
var useInteractionItemProps = (data, skip) => {
  const {
    instance
  } = useChartContext();
  const interactionActive = React13.useRef(false);
  const onPointerEnter = useEventCallback_default(() => {
    interactionActive.current = true;
    instance.setItemInteraction(data, {
      interaction: "pointer"
    });
    instance.setHighlight(data);
  });
  const onPointerLeave = useEventCallback_default(() => {
    interactionActive.current = false;
    instance.removeItemInteraction(data);
    instance.clearHighlight();
  });
  React13.useEffect(() => {
    return () => {
      if (interactionActive.current) {
        onPointerLeave();
      }
    };
  }, [onPointerLeave]);
  return React13.useMemo(() => skip ? {} : {
    onPointerEnter,
    onPointerLeave,
    onPointerDown
  }, [skip, onPointerEnter, onPointerLeave]);
};

// node_modules/@mui/x-charts/esm/PieChart/PieArc.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var _excluded9 = ["className", "classes", "color", "dataIndex", "id", "isFaded", "isHighlighted", "isFocused", "onClick", "cornerRadius", "startAngle", "endAngle", "innerRadius", "outerRadius", "paddingAngle", "skipAnimation", "stroke", "skipInteraction"];
function getPieArcUtilityClass(slot) {
  return generateUtilityClass("MuiPieArc", slot);
}
var pieArcClasses = generateUtilityClasses("MuiPieArc", ["root", "highlighted", "faded", "series", "focusIndicator"]);
var useUtilityClasses8 = (ownerState) => {
  const {
    classes,
    id,
    isFaded,
    isHighlighted,
    dataIndex
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`, `data-index-${dataIndex}`, isHighlighted && "highlighted", isFaded && "faded"]
  };
  return composeClasses(slots, getPieArcUtilityClass, classes);
};
var PieArcRoot = styled_default("path", {
  name: "MuiPieArc",
  slot: "Root",
  overridesResolver: (_, styles) => styles.arc
  // FIXME: Inconsistent naming with slot
})({
  transitionProperty: "opacity, fill, filter",
  transitionDuration: `${ANIMATION_DURATION_MS}ms`,
  transitionTimingFunction: ANIMATION_TIMING_FUNCTION
});
var PieArc = React14.forwardRef(function PieArc2(props, ref) {
  const {
    className,
    classes: innerClasses,
    color,
    dataIndex,
    id,
    isFaded,
    isHighlighted,
    isFocused,
    onClick,
    cornerRadius,
    startAngle,
    endAngle,
    innerRadius,
    outerRadius,
    paddingAngle,
    skipAnimation,
    stroke: strokeProp,
    skipInteraction
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded9);
  const theme = useTheme();
  const stroke = strokeProp ?? (theme.vars || theme).palette.background.paper;
  const ownerState = {
    id,
    dataIndex,
    classes: innerClasses,
    color,
    isFaded,
    isHighlighted,
    isFocused
  };
  const classes = useUtilityClasses8(ownerState);
  const interactionProps = useInteractionItemProps({
    type: "pie",
    seriesId: id,
    dataIndex
  }, skipInteraction);
  const animatedProps = useAnimatePieArc({
    cornerRadius,
    startAngle,
    endAngle,
    innerRadius,
    outerRadius,
    paddingAngle,
    skipAnimation,
    ref
  });
  return (0, import_jsx_runtime13.jsx)(PieArcRoot, _extends({
    onClick,
    cursor: onClick ? "pointer" : "unset",
    ownerState,
    className: clsx_default(classes.root, className),
    fill: ownerState.color,
    opacity: ownerState.isFaded ? 0.3 : 1,
    filter: ownerState.isHighlighted ? "brightness(120%)" : "none",
    stroke,
    strokeWidth: 1,
    strokeLinejoin: "round",
    "data-highlighted": ownerState.isHighlighted || void 0,
    "data-faded": ownerState.isFaded || void 0
  }, other, interactionProps, animatedProps));
});
if (true) PieArc.displayName = "PieArc";
true ? PieArc.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  classes: import_prop_types11.default.object,
  cornerRadius: import_prop_types11.default.number.isRequired,
  dataIndex: import_prop_types11.default.number.isRequired,
  endAngle: import_prop_types11.default.number.isRequired,
  id: import_prop_types11.default.oneOfType([import_prop_types11.default.number, import_prop_types11.default.string]).isRequired,
  innerRadius: import_prop_types11.default.number.isRequired,
  isFaded: import_prop_types11.default.bool.isRequired,
  isFocused: import_prop_types11.default.bool.isRequired,
  isHighlighted: import_prop_types11.default.bool.isRequired,
  outerRadius: import_prop_types11.default.number.isRequired,
  paddingAngle: import_prop_types11.default.number.isRequired,
  /**
   * If `true`, the animation is disabled.
   */
  skipAnimation: import_prop_types11.default.bool,
  /**
   * If `true`, the default event handlers are disabled.
   * Those are used, for example, to display a tooltip or highlight the arc on hover.
   */
  skipInteraction: import_prop_types11.default.bool,
  startAngle: import_prop_types11.default.number.isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/PieChart/dataTransform/useTransformData.js
var React15 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/hooks/useIsItemFocusedGetter.js
function useIsItemFocusedGetter() {
  const focusedItem = useFocusedItem();
  return (item) => focusedItem !== null && focusedItem.seriesType === item.seriesType && focusedItem.seriesId === item.seriesId && focusedItem.dataIndex === item.dataIndex;
}

// node_modules/@mui/x-charts/esm/PieChart/dataTransform/useTransformData.js
function useTransformData(series) {
  const {
    id: seriesId,
    data,
    faded,
    highlighted,
    paddingAngle: basePaddingAngle = 0,
    innerRadius: baseInnerRadius = 0,
    arcLabelRadius: baseArcLabelRadius,
    outerRadius: baseOuterRadius,
    cornerRadius: baseCornerRadius = 0
  } = series;
  const {
    isFaded: isItemFaded,
    isHighlighted: isItemHighlighted
  } = useItemHighlightedGetter();
  const isItemFocused = useIsItemFocusedGetter();
  const dataWithHighlight = React15.useMemo(() => data.map((item, itemIndex) => {
    const currentItem = {
      seriesId,
      dataIndex: itemIndex
    };
    const isHighlighted = isItemHighlighted(currentItem);
    const isFaded = !isHighlighted && isItemFaded(currentItem);
    const isFocused = isItemFocused({
      seriesType: "pie",
      seriesId,
      dataIndex: itemIndex
    });
    const attributesOverride = _extends({
      additionalRadius: 0
    }, isFaded && faded || isHighlighted && highlighted || {});
    const paddingAngle = Math.max(0, deg2rad(attributesOverride.paddingAngle ?? basePaddingAngle));
    const innerRadius = Math.max(0, attributesOverride.innerRadius ?? baseInnerRadius);
    const outerRadius = Math.max(0, attributesOverride.outerRadius ?? baseOuterRadius + attributesOverride.additionalRadius);
    const cornerRadius = attributesOverride.cornerRadius ?? baseCornerRadius;
    const arcLabelRadius = attributesOverride.arcLabelRadius ?? baseArcLabelRadius ?? (innerRadius + outerRadius) / 2;
    return _extends({}, item, attributesOverride, {
      dataIndex: itemIndex,
      isFaded,
      isHighlighted,
      isFocused,
      paddingAngle,
      innerRadius,
      outerRadius,
      cornerRadius,
      arcLabelRadius
    });
  }), [baseCornerRadius, baseInnerRadius, baseOuterRadius, basePaddingAngle, baseArcLabelRadius, data, faded, highlighted, isItemFaded, isItemHighlighted, isItemFocused, seriesId]);
  return dataWithHighlight;
}

// node_modules/@mui/x-charts/esm/PieChart/PieArcPlot.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var _excluded10 = ["slots", "slotProps", "innerRadius", "outerRadius", "cornerRadius", "paddingAngle", "id", "highlighted", "faded", "data", "onItemClick", "skipAnimation"];
function PieArcPlot(props) {
  const {
    slots,
    slotProps,
    innerRadius = 0,
    outerRadius,
    cornerRadius = 0,
    paddingAngle = 0,
    id,
    highlighted,
    faded = {
      additionalRadius: -5
    },
    data,
    onItemClick,
    skipAnimation
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded10);
  const theme = useTheme();
  const transformedData = useTransformData({
    innerRadius,
    outerRadius,
    cornerRadius,
    paddingAngle,
    id,
    highlighted,
    faded,
    data
  });
  const {
    dataIndex: focusedIndex = -1
  } = useFocusedItem() ?? {};
  const focusedItem = focusedIndex !== -1 ? transformedData[focusedIndex] : null;
  if (data.length === 0) {
    return null;
  }
  const Arc = (slots == null ? void 0 : slots.pieArc) ?? PieArc;
  return (0, import_jsx_runtime14.jsxs)("g", _extends({}, other, {
    children: [transformedData.map((item, index) => (0, import_jsx_runtime14.jsx)(Arc, _extends({
      startAngle: item.startAngle,
      endAngle: item.endAngle,
      paddingAngle: item.paddingAngle,
      innerRadius: item.innerRadius,
      outerRadius: item.outerRadius,
      cornerRadius: item.cornerRadius,
      skipAnimation: skipAnimation ?? false,
      id,
      color: item.color,
      dataIndex: index,
      isFaded: item.isFaded,
      isHighlighted: item.isHighlighted,
      isFocused: item.isFocused,
      onClick: onItemClick && ((event) => {
        onItemClick(event, {
          type: "pie",
          seriesId: id,
          dataIndex: index
        }, item);
      })
    }, slotProps == null ? void 0 : slotProps.pieArc), item.dataIndex)), focusedItem && (0, import_jsx_runtime14.jsx)(Arc, {
      startAngle: focusedItem.startAngle,
      endAngle: focusedItem.endAngle,
      paddingAngle: focusedItem.paddingAngle,
      innerRadius: focusedItem.innerRadius,
      color: "transparent",
      pointerEvents: "none",
      skipInteraction: true,
      outerRadius: focusedItem.outerRadius,
      cornerRadius: focusedItem.cornerRadius,
      skipAnimation: true,
      stroke: (theme.vars ?? theme).palette.text.primary,
      id,
      className: pieArcClasses.focusIndicator,
      dataIndex: focusedIndex,
      isFaded: false,
      isHighlighted: false,
      isFocused: false,
      strokeWidth: 3
    })]
  }));
}
true ? PieArcPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The radius between circle center and the arc label in px.
   * @default (innerRadius - outerRadius) / 2
   */
  arcLabelRadius: import_prop_types12.default.number,
  /**
   * The radius applied to arc corners (similar to border radius).
   * @default 0
   */
  cornerRadius: import_prop_types12.default.number,
  data: import_prop_types12.default.arrayOf(import_prop_types12.default.shape({
    color: import_prop_types12.default.string.isRequired,
    endAngle: import_prop_types12.default.number.isRequired,
    formattedValue: import_prop_types12.default.string.isRequired,
    id: import_prop_types12.default.oneOfType([import_prop_types12.default.number, import_prop_types12.default.string]),
    index: import_prop_types12.default.number.isRequired,
    label: import_prop_types12.default.oneOfType([import_prop_types12.default.func, import_prop_types12.default.string]),
    labelMarkType: import_prop_types12.default.oneOfType([import_prop_types12.default.oneOf(["circle", "line", "square"]), import_prop_types12.default.func]),
    padAngle: import_prop_types12.default.number.isRequired,
    startAngle: import_prop_types12.default.number.isRequired,
    value: import_prop_types12.default.number.isRequired
  })).isRequired,
  /**
   * Override the arc attributes when it is faded.
   * @default { additionalRadius: -5 }
   */
  faded: import_prop_types12.default.shape({
    additionalRadius: import_prop_types12.default.number,
    arcLabelRadius: import_prop_types12.default.number,
    color: import_prop_types12.default.string,
    cornerRadius: import_prop_types12.default.number,
    innerRadius: import_prop_types12.default.number,
    outerRadius: import_prop_types12.default.number,
    paddingAngle: import_prop_types12.default.number
  }),
  /**
   * Override the arc attributes when it is highlighted.
   */
  highlighted: import_prop_types12.default.shape({
    additionalRadius: import_prop_types12.default.number,
    arcLabelRadius: import_prop_types12.default.number,
    color: import_prop_types12.default.string,
    cornerRadius: import_prop_types12.default.number,
    innerRadius: import_prop_types12.default.number,
    outerRadius: import_prop_types12.default.number,
    paddingAngle: import_prop_types12.default.number
  }),
  /**
   * The id of this series.
   */
  id: import_prop_types12.default.oneOfType([import_prop_types12.default.number, import_prop_types12.default.string]).isRequired,
  /**
   * The radius between circle center and the beginning of the arc.
   * @default 0
   */
  innerRadius: import_prop_types12.default.number,
  /**
   * Callback fired when a pie item is clicked.
   * @param {React.MouseEvent<SVGPathElement, MouseEvent>} event The event source of the callback.
   * @param {PieItemIdentifier} pieItemIdentifier The pie item identifier.
   * @param {DefaultizedPieValueType} item The pie item.
   */
  onItemClick: import_prop_types12.default.func,
  /**
   * The radius between circle center and the end of the arc.
   */
  outerRadius: import_prop_types12.default.number.isRequired,
  /**
   * The padding angle (deg) between two arcs.
   * @default 0
   */
  paddingAngle: import_prop_types12.default.number,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types12.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types12.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types12.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/PieChart/PieArcLabelPlot.js
var React18 = __toESM(require_react(), 1);
var import_prop_types14 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/PieChart/PieArcLabel.js
var React17 = __toESM(require_react(), 1);
var import_prop_types13 = __toESM(require_prop_types(), 1);
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var _excluded11 = ["id", "classes", "color", "startAngle", "endAngle", "paddingAngle", "arcLabelRadius", "innerRadius", "outerRadius", "cornerRadius", "formattedArcLabel", "isHighlighted", "isFaded", "style", "skipAnimation"];
function getPieArcLabelUtilityClass(slot) {
  return generateUtilityClass("MuiPieArcLabel", slot);
}
var pieArcLabelClasses = generateUtilityClasses("MuiPieArcLabel", ["root", "highlighted", "faded", "animate", "series"]);
var useUtilityClasses9 = (ownerState) => {
  const {
    classes,
    id,
    isFaded,
    isHighlighted,
    skipAnimation
  } = ownerState;
  const slots = {
    root: ["root", `series-${id}`, isHighlighted && "highlighted", isFaded && "faded", !skipAnimation && "animate"]
  };
  return composeClasses(slots, getPieArcLabelUtilityClass, classes);
};
var PieArcLabelRoot = styled_default("text", {
  name: "MuiPieArcLabel",
  slot: "Root"
})(({
  theme
}) => ({
  fill: (theme.vars || theme).palette.text.primary,
  textAnchor: "middle",
  dominantBaseline: "middle",
  pointerEvents: "none",
  animationName: "animate-opacity",
  animationDuration: "0s",
  animationTimingFunction: ANIMATION_TIMING_FUNCTION,
  [`&.${pieArcLabelClasses.animate}`]: {
    animationDuration: `${ANIMATION_DURATION_MS}ms`
  },
  "@keyframes animate-opacity": {
    from: {
      opacity: 0
    }
  }
}));
var PieArcLabel = React17.forwardRef(function PieArcLabel2(props, ref) {
  const {
    id,
    classes: innerClasses,
    color,
    startAngle,
    endAngle,
    paddingAngle,
    arcLabelRadius,
    cornerRadius,
    formattedArcLabel,
    isHighlighted,
    isFaded,
    skipAnimation
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded11);
  const ownerState = {
    id,
    classes: innerClasses,
    color,
    isFaded,
    isHighlighted,
    skipAnimation
  };
  const classes = useUtilityClasses9(ownerState);
  const animatedProps = useAnimatePieArcLabel({
    cornerRadius,
    startAngle,
    endAngle,
    innerRadius: arcLabelRadius,
    outerRadius: arcLabelRadius,
    paddingAngle,
    skipAnimation,
    ref
  });
  return (0, import_jsx_runtime15.jsx)(PieArcLabelRoot, _extends({
    className: classes.root
  }, other, animatedProps, {
    children: formattedArcLabel
  }));
});
if (true) PieArcLabel.displayName = "PieArcLabel";
true ? PieArcLabel.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  arcLabelRadius: import_prop_types13.default.number.isRequired,
  classes: import_prop_types13.default.object,
  color: import_prop_types13.default.string.isRequired,
  cornerRadius: import_prop_types13.default.number.isRequired,
  endAngle: import_prop_types13.default.number.isRequired,
  formattedArcLabel: import_prop_types13.default.string,
  id: import_prop_types13.default.oneOfType([import_prop_types13.default.number, import_prop_types13.default.string]).isRequired,
  innerRadius: import_prop_types13.default.number.isRequired,
  isFaded: import_prop_types13.default.bool.isRequired,
  isHighlighted: import_prop_types13.default.bool.isRequired,
  outerRadius: import_prop_types13.default.number.isRequired,
  paddingAngle: import_prop_types13.default.number.isRequired,
  skipAnimation: import_prop_types13.default.bool.isRequired,
  startAngle: import_prop_types13.default.number.isRequired
} : void 0;

// node_modules/@mui/x-charts/esm/PieChart/PieArcLabelPlot.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var _excluded12 = ["arcLabel", "arcLabelMinAngle", "arcLabelRadius", "cornerRadius", "data", "faded", "highlighted", "id", "innerRadius", "outerRadius", "paddingAngle", "skipAnimation", "slotProps", "slots"];
var RATIO = 180 / Math.PI;
function getItemLabel(arcLabel, arcLabelMinAngle, item) {
  var _a;
  if (!arcLabel) {
    return null;
  }
  const angle = (item.endAngle - item.startAngle) * RATIO;
  if (angle < arcLabelMinAngle) {
    return null;
  }
  switch (arcLabel) {
    case "label":
      return getLabel(item.label, "arc");
    case "value":
      return (_a = item.value) == null ? void 0 : _a.toString();
    case "formattedValue":
      return item.formattedValue;
    default:
      return arcLabel(_extends({}, item, {
        label: getLabel(item.label, "arc")
      }));
  }
}
function PieArcLabelPlot(props) {
  const {
    arcLabel,
    arcLabelMinAngle = 0,
    arcLabelRadius,
    cornerRadius = 0,
    data,
    faded = {
      additionalRadius: -5
    },
    highlighted,
    id,
    innerRadius,
    outerRadius,
    paddingAngle = 0,
    skipAnimation,
    slotProps,
    slots
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded12);
  const transformedData = useTransformData({
    innerRadius,
    outerRadius,
    arcLabelRadius,
    cornerRadius,
    paddingAngle,
    id,
    highlighted,
    faded,
    data
  });
  if (data.length === 0) {
    return null;
  }
  const ArcLabel = (slots == null ? void 0 : slots.pieArcLabel) ?? PieArcLabel;
  return (0, import_jsx_runtime16.jsx)("g", _extends({}, other, {
    children: transformedData.map((item) => (0, import_jsx_runtime16.jsx)(ArcLabel, _extends({
      startAngle: item.startAngle,
      endAngle: item.endAngle,
      paddingAngle: item.paddingAngle,
      innerRadius: item.innerRadius,
      outerRadius: item.outerRadius,
      arcLabelRadius: item.arcLabelRadius,
      cornerRadius: item.cornerRadius,
      id,
      color: item.color,
      isFaded: item.isFaded,
      isHighlighted: item.isHighlighted,
      formattedArcLabel: getItemLabel(arcLabel, arcLabelMinAngle, item),
      skipAnimation: skipAnimation ?? false
    }, slotProps == null ? void 0 : slotProps.pieArcLabel), item.id ?? item.dataIndex))
  }));
}
true ? PieArcLabelPlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The label displayed into the arc.
   */
  arcLabel: import_prop_types14.default.oneOfType([import_prop_types14.default.oneOf(["formattedValue", "label", "value"]), import_prop_types14.default.func]),
  /**
   * The minimal angle required to display the arc label.
   * @default 0
   */
  arcLabelMinAngle: import_prop_types14.default.number,
  /**
   * The radius between circle center and the arc label in px.
   * @default (innerRadius - outerRadius) / 2
   */
  arcLabelRadius: import_prop_types14.default.number,
  /**
   * The radius applied to arc corners (similar to border radius).
   * @default 0
   */
  cornerRadius: import_prop_types14.default.number,
  data: import_prop_types14.default.arrayOf(import_prop_types14.default.shape({
    color: import_prop_types14.default.string.isRequired,
    endAngle: import_prop_types14.default.number.isRequired,
    formattedValue: import_prop_types14.default.string.isRequired,
    id: import_prop_types14.default.oneOfType([import_prop_types14.default.number, import_prop_types14.default.string]),
    index: import_prop_types14.default.number.isRequired,
    label: import_prop_types14.default.oneOfType([import_prop_types14.default.func, import_prop_types14.default.string]),
    labelMarkType: import_prop_types14.default.oneOfType([import_prop_types14.default.oneOf(["circle", "line", "square"]), import_prop_types14.default.func]),
    padAngle: import_prop_types14.default.number.isRequired,
    startAngle: import_prop_types14.default.number.isRequired,
    value: import_prop_types14.default.number.isRequired
  })).isRequired,
  /**
   * Override the arc attributes when it is faded.
   * @default { additionalRadius: -5 }
   */
  faded: import_prop_types14.default.shape({
    additionalRadius: import_prop_types14.default.number,
    arcLabelRadius: import_prop_types14.default.number,
    color: import_prop_types14.default.string,
    cornerRadius: import_prop_types14.default.number,
    innerRadius: import_prop_types14.default.number,
    outerRadius: import_prop_types14.default.number,
    paddingAngle: import_prop_types14.default.number
  }),
  /**
   * Override the arc attributes when it is highlighted.
   */
  highlighted: import_prop_types14.default.shape({
    additionalRadius: import_prop_types14.default.number,
    arcLabelRadius: import_prop_types14.default.number,
    color: import_prop_types14.default.string,
    cornerRadius: import_prop_types14.default.number,
    innerRadius: import_prop_types14.default.number,
    outerRadius: import_prop_types14.default.number,
    paddingAngle: import_prop_types14.default.number
  }),
  /**
   * The id of this series.
   */
  id: import_prop_types14.default.oneOfType([import_prop_types14.default.number, import_prop_types14.default.string]).isRequired,
  /**
   * The radius between circle center and the beginning of the arc.
   * @default 0
   */
  innerRadius: import_prop_types14.default.number,
  /**
   * The radius between circle center and the end of the arc.
   */
  outerRadius: import_prop_types14.default.number.isRequired,
  /**
   * The padding angle (deg) between two arcs.
   * @default 0
   */
  paddingAngle: import_prop_types14.default.number,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types14.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types14.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types14.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/PieChart/pieClasses.js
function getPieUtilityClass(slot) {
  return generateUtilityClass("MuiPieChart", slot);
}
var pieClasses = generateUtilityClasses("MuiPieChart", ["root", "series", "seriesLabels"]);
var useUtilityClasses10 = (classes) => {
  const slots = {
    root: ["root"],
    series: ["series"],
    seriesLabels: ["seriesLabels"]
  };
  return composeClasses(slots, getPieUtilityClass, classes);
};

// node_modules/@mui/x-charts/esm/PieChart/PiePlot.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
function PiePlot(props) {
  const {
    skipAnimation: inSkipAnimation,
    slots,
    slotProps,
    onItemClick
  } = props;
  const seriesData = usePieSeriesContext();
  const {
    left,
    top,
    width,
    height
  } = useDrawingArea();
  const skipAnimation = useSkipAnimation(inSkipAnimation);
  const classes = useUtilityClasses10();
  if (seriesData === void 0) {
    return null;
  }
  const {
    series,
    seriesOrder
  } = seriesData;
  return (0, import_jsx_runtime17.jsxs)("g", {
    children: [seriesOrder.map((seriesId) => {
      const {
        innerRadius: innerRadiusParam,
        outerRadius: outerRadiusParam,
        cornerRadius,
        paddingAngle,
        data,
        cx: cxParam,
        cy: cyParam,
        highlighted,
        faded
      } = series[seriesId];
      const {
        cx,
        cy,
        availableRadius
      } = getPieCoordinates({
        cx: cxParam,
        cy: cyParam
      }, {
        width,
        height
      });
      const outerRadius = getPercentageValue(outerRadiusParam ?? availableRadius, availableRadius);
      const innerRadius = getPercentageValue(innerRadiusParam ?? 0, availableRadius);
      return (0, import_jsx_runtime17.jsx)("g", {
        className: classes.series,
        transform: `translate(${left + cx}, ${top + cy})`,
        "data-series": seriesId,
        children: (0, import_jsx_runtime17.jsx)(PieArcPlot, {
          innerRadius,
          outerRadius,
          cornerRadius,
          paddingAngle,
          id: seriesId,
          data,
          skipAnimation,
          highlighted,
          faded,
          onItemClick,
          slots,
          slotProps
        })
      }, seriesId);
    }), seriesOrder.map((seriesId) => {
      const {
        innerRadius: innerRadiusParam,
        outerRadius: outerRadiusParam,
        arcLabelRadius: arcLabelRadiusParam,
        cornerRadius,
        paddingAngle,
        arcLabel,
        arcLabelMinAngle,
        data,
        cx: cxParam,
        cy: cyParam
      } = series[seriesId];
      const {
        cx,
        cy,
        availableRadius
      } = getPieCoordinates({
        cx: cxParam,
        cy: cyParam
      }, {
        width,
        height
      });
      const outerRadius = getPercentageValue(outerRadiusParam ?? availableRadius, availableRadius);
      const innerRadius = getPercentageValue(innerRadiusParam ?? 0, availableRadius);
      const arcLabelRadius = arcLabelRadiusParam === void 0 ? (outerRadius + innerRadius) / 2 : getPercentageValue(arcLabelRadiusParam, availableRadius);
      return (0, import_jsx_runtime17.jsx)("g", {
        className: classes.seriesLabels,
        transform: `translate(${left + cx}, ${top + cy})`,
        "data-series": seriesId,
        children: (0, import_jsx_runtime17.jsx)(PieArcLabelPlot, {
          innerRadius,
          outerRadius: outerRadius ?? availableRadius,
          arcLabelRadius,
          cornerRadius,
          paddingAngle,
          id: seriesId,
          data,
          skipAnimation,
          arcLabel,
          arcLabelMinAngle,
          slots,
          slotProps
        })
      }, seriesId);
    })]
  });
}
true ? PiePlot.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Callback fired when a pie item is clicked.
   * @param {React.MouseEvent<SVGPathElement, MouseEvent>} event The event source of the callback.
   * @param {PieItemIdentifier} pieItemIdentifier The pie item identifier.
   * @param {DefaultizedPieValueType} item The pie item.
   */
  onItemClick: import_prop_types15.default.func,
  /**
   * If `true`, animations are skipped.
   * @default false
   */
  skipAnimation: import_prop_types15.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types15.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types15.default.object
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsOverlay/ChartsOverlay.js
var React19 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/ChartsOverlay/ChartsLoadingOverlay.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var _excluded13 = ["message"];
var StyledText = styled_default("text")(({
  theme
}) => _extends({}, theme.typography.body2, {
  stroke: "none",
  fill: (theme.vars || theme).palette.text.primary,
  shapeRendering: "crispEdges",
  textAnchor: "middle",
  dominantBaseline: "middle"
}));
function ChartsLoadingOverlay(props) {
  const {
    message
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded13);
  const {
    top,
    left,
    height,
    width
  } = useDrawingArea();
  const {
    localeText
  } = useChartsLocalization();
  return (0, import_jsx_runtime18.jsx)(StyledText, _extends({
    x: left + width / 2,
    y: top + height / 2
  }, other, {
    children: message ?? localeText.loading
  }));
}

// node_modules/@mui/x-charts/esm/ChartsOverlay/ChartsNoDataOverlay.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var _excluded14 = ["message"];
var StyledText2 = styled_default("text")(({
  theme
}) => _extends({}, theme.typography.body2, {
  stroke: "none",
  fill: (theme.vars || theme).palette.text.primary,
  shapeRendering: "crispEdges",
  textAnchor: "middle",
  dominantBaseline: "middle"
}));
function ChartsNoDataOverlay(props) {
  const {
    message
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded14);
  const {
    top,
    left,
    height,
    width
  } = useDrawingArea();
  const {
    localeText
  } = useChartsLocalization();
  return (0, import_jsx_runtime19.jsx)(StyledText2, _extends({
    x: left + width / 2,
    y: top + height / 2
  }, other, {
    children: message ?? localeText.noData
  }));
}

// node_modules/@mui/x-charts/esm/ChartsOverlay/ChartsOverlay.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
function useNoData() {
  const seriesPerType = useSeries();
  return Object.values(seriesPerType).every((seriesOfGivenType) => {
    if (!seriesOfGivenType) {
      return true;
    }
    const {
      series,
      seriesOrder
    } = seriesOfGivenType;
    return seriesOrder.every((seriesId) => {
      const seriesItem = series[seriesId];
      if (seriesItem.type === "sankey") {
        return seriesItem.data.links.length === 0;
      }
      return seriesItem.data.length === 0;
    });
  });
}
function ChartsOverlay(props) {
  var _a, _b, _c, _d;
  const noData = useNoData();
  if (props.loading) {
    const LoadingOverlay = ((_a = props.slots) == null ? void 0 : _a.loadingOverlay) ?? ChartsLoadingOverlay;
    return (0, import_jsx_runtime20.jsx)(LoadingOverlay, _extends({}, (_b = props.slotProps) == null ? void 0 : _b.loadingOverlay));
  }
  if (noData) {
    const NoDataOverlay = ((_c = props.slots) == null ? void 0 : _c.noDataOverlay) ?? ChartsNoDataOverlay;
    return (0, import_jsx_runtime20.jsx)(NoDataOverlay, _extends({}, (_d = props.slotProps) == null ? void 0 : _d.noDataOverlay));
  }
  return null;
}

// node_modules/@mui/x-charts/esm/ChartDataProvider/ChartDataProvider.js
var React22 = __toESM(require_react(), 1);
var import_prop_types16 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/internals/material/index.js
var baseSlots = {
  baseButton: Button_default,
  baseIconButton: IconButton_default
};
var iconSlots = {};
var defaultSlotsMaterial = _extends({}, baseSlots, iconSlots);

// node_modules/@mui/x-charts/esm/context/ChartsSlotsContext.js
var React20 = __toESM(require_react(), 1);
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var ChartsSlotsContext = React20.createContext(null);
if (true) ChartsSlotsContext.displayName = "ChartsSlotsContext";
function useChartsSlots() {
  const context = React20.useContext(ChartsSlotsContext);
  if (context == null) {
    throw new Error(["MUI X Charts: Could not find the Charts Slots context.", "It looks like you rendered your component outside of a ChartDataProvider.", "This can also happen if you are bundling multiple versions of the library."].join("\n"));
  }
  return context;
}
function ChartsSlotsProvider(props) {
  const {
    slots,
    slotProps = {},
    defaultSlots,
    children
  } = props;
  const value = React20.useMemo(() => ({
    slots: _extends({}, defaultSlots, slots),
    slotProps
  }), [defaultSlots, slots, slotProps]);
  return (0, import_jsx_runtime21.jsx)(ChartsSlotsContext.Provider, {
    value,
    children
  });
}

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartClosestPoint/useChartClosestPoint.js
var React21 = __toESM(require_react(), 1);

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartClosestPoint/findClosestPoints.js
function findClosestPoints(flatbush, drawingArea, seriesData, xScale, yScale, xZoomStart, xZoomEnd, yZoomStart, yZoomEnd, svgPointX, svgPointY, maxRadius = Infinity, maxResults = 1) {
  const originalXScale = xScale.copy();
  const originalYScale = yScale.copy();
  originalXScale.range([0, 1]);
  originalYScale.range([0, 1]);
  const excludeIfOutsideDrawingArea = function excludeIfOutsideDrawingArea2(index) {
    const x = originalXScale(seriesData[index].x);
    const y = originalYScale(seriesData[index].y);
    return x >= xZoomStart && x <= xZoomEnd && y >= yZoomStart && y <= yZoomEnd;
  };
  const fx = xScale.range()[1] - xScale.range()[0];
  const fy = yScale.range()[1] - yScale.range()[0];
  const fxSq = fx * fx;
  const fySq = fy * fy;
  function sqDistFn(dx, dy) {
    return fxSq * dx * dx + fySq * dy * dy;
  }
  const pointX = originalXScale(invertScale(xScale, svgPointX, (dataIndex) => seriesData[dataIndex].x));
  const pointY = originalYScale(invertScale(yScale, svgPointY, (dataIndex) => seriesData[dataIndex].y));
  return flatbush.neighbors(pointX, pointY, maxResults, maxRadius != null ? maxRadius * maxRadius : Infinity, excludeIfOutsideDrawingArea, sqDistFn);
}
function invertScale(scale, value, getDataPoint) {
  if (isOrdinalScale(scale)) {
    const dataIndex = scale.bandwidth() === 0 ? Math.floor((value - Math.min(...scale.range()) + scale.step() / 2) / scale.step()) : Math.floor((value - Math.min(...scale.range())) / scale.step());
    return getDataPoint(dataIndex);
  }
  return scale.invert(value);
}

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartClosestPoint/useChartClosestPoint.js
var useChartClosestPoint = ({
  svgRef,
  params,
  store,
  instance
}) => {
  var _a;
  const {
    disableVoronoi,
    voronoiMaxRadius,
    onItemClick
  } = params;
  const drawingArea = useSelector(store, selectorChartDrawingArea);
  const {
    axis: xAxis,
    axisIds: xAxisIds
  } = useSelector(store, selectorChartXAxis);
  const {
    axis: yAxis,
    axisIds: yAxisIds
  } = useSelector(store, selectorChartYAxis);
  const zoomIsInteracting = useSelector(store, selectorChartZoomIsInteracting);
  const {
    series,
    seriesOrder
  } = ((_a = useSelector(store, selectorChartSeriesProcessed)) == null ? void 0 : _a.scatter) ?? {};
  const flatbushMap = useSelector(store, zoomIsInteracting ? selectorChartSeriesEmptyFlatbushMap : selectorChartSeriesFlatbushMap);
  const defaultXAxisId = xAxisIds[0];
  const defaultYAxisId = yAxisIds[0];
  useEnhancedEffect_default(() => {
    store.set("voronoi", {
      isVoronoiEnabled: !disableVoronoi
    });
  }, [store, disableVoronoi]);
  React21.useEffect(() => {
    if (svgRef.current === null || disableVoronoi) {
      return void 0;
    }
    const element = svgRef.current;
    function getClosestPoint(event) {
      const svgPoint = getSVGPoint(element, event);
      if (!instance.isPointInside(svgPoint.x, svgPoint.y)) {
        return "outside-chart";
      }
      let closestPoint = void 0;
      for (const seriesId of seriesOrder ?? []) {
        const aSeries = (series ?? {})[seriesId];
        const flatbush = flatbushMap.get(seriesId);
        if (!flatbush) {
          continue;
        }
        const xAxisId = aSeries.xAxisId ?? defaultXAxisId;
        const yAxisId = aSeries.yAxisId ?? defaultYAxisId;
        const xAxisZoom = selectorChartAxisZoomData(store.getSnapshot(), xAxisId);
        const yAxisZoom = selectorChartAxisZoomData(store.getSnapshot(), yAxisId);
        const maxRadius = voronoiMaxRadius === "item" ? aSeries.markerSize : voronoiMaxRadius;
        const xZoomStart = ((xAxisZoom == null ? void 0 : xAxisZoom.start) ?? 0) / 100;
        const xZoomEnd = ((xAxisZoom == null ? void 0 : xAxisZoom.end) ?? 100) / 100;
        const yZoomStart = ((yAxisZoom == null ? void 0 : yAxisZoom.start) ?? 0) / 100;
        const yZoomEnd = ((yAxisZoom == null ? void 0 : yAxisZoom.end) ?? 100) / 100;
        const xScale = xAxis[xAxisId].scale;
        const yScale = yAxis[yAxisId].scale;
        const closestPointIndex = findClosestPoints(flatbush, drawingArea, aSeries.data, xScale, yScale, xZoomStart, xZoomEnd, yZoomStart, yZoomEnd, svgPoint.x, svgPoint.y, maxRadius)[0];
        if (closestPointIndex === void 0) {
          continue;
        }
        const point = aSeries.data[closestPointIndex];
        const scaledX = xScale(point.x);
        const scaledY = yScale(point.y);
        const distSq = (scaledX - svgPoint.x) ** 2 + (scaledY - svgPoint.y) ** 2;
        if (closestPoint === void 0 || distSq < closestPoint.distanceSq) {
          closestPoint = {
            dataIndex: closestPointIndex,
            seriesId,
            distanceSq: distSq
          };
        }
      }
      if (closestPoint === void 0) {
        return "no-point-found";
      }
      return {
        seriesId: closestPoint.seriesId,
        dataIndex: closestPoint.dataIndex
      };
    }
    const moveEndHandler = instance.addInteractionListener("moveEnd", (event) => {
      var _a2, _b;
      if (!event.detail.activeGestures.pan) {
        (_a2 = instance.cleanInteraction) == null ? void 0 : _a2.call(instance);
        (_b = instance.clearHighlight) == null ? void 0 : _b.call(instance);
      }
    });
    const panEndHandler = instance.addInteractionListener("panEnd", (event) => {
      var _a2, _b;
      if (!event.detail.activeGestures.move) {
        (_a2 = instance.cleanInteraction) == null ? void 0 : _a2.call(instance);
        (_b = instance.clearHighlight) == null ? void 0 : _b.call(instance);
      }
    });
    const pressEndHandler = instance.addInteractionListener("quickPressEnd", (event) => {
      var _a2, _b;
      if (!event.detail.activeGestures.move && !event.detail.activeGestures.pan) {
        (_a2 = instance.cleanInteraction) == null ? void 0 : _a2.call(instance);
        (_b = instance.clearHighlight) == null ? void 0 : _b.call(instance);
      }
    });
    const gestureHandler = (event) => {
      var _a2, _b, _c, _d, _e, _f;
      const closestPoint = getClosestPoint(event.detail.srcEvent);
      if (closestPoint === "outside-chart") {
        (_a2 = instance.cleanInteraction) == null ? void 0 : _a2.call(instance);
        (_b = instance.clearHighlight) == null ? void 0 : _b.call(instance);
        return;
      }
      if (closestPoint === "outside-voronoi-max-radius" || closestPoint === "no-point-found") {
        (_c = instance.removeItemInteraction) == null ? void 0 : _c.call(instance);
        (_d = instance.clearHighlight) == null ? void 0 : _d.call(instance);
        return;
      }
      const {
        seriesId,
        dataIndex
      } = closestPoint;
      (_e = instance.setItemInteraction) == null ? void 0 : _e.call(instance, {
        type: "scatter",
        seriesId,
        dataIndex
      }, {
        interaction: "pointer"
      });
      (_f = instance.setHighlight) == null ? void 0 : _f.call(instance, {
        seriesId,
        dataIndex
      });
    };
    const tapHandler = instance.addInteractionListener("tap", (event) => {
      const closestPoint = getClosestPoint(event.detail.srcEvent);
      if (typeof closestPoint !== "string" && onItemClick) {
        const {
          seriesId,
          dataIndex
        } = closestPoint;
        onItemClick(event.detail.srcEvent, {
          type: "scatter",
          seriesId,
          dataIndex
        });
      }
    });
    const moveHandler = instance.addInteractionListener("move", gestureHandler);
    const panHandler = instance.addInteractionListener("pan", gestureHandler);
    const pressHandler = instance.addInteractionListener("quickPress", gestureHandler);
    return () => {
      tapHandler.cleanup();
      moveHandler.cleanup();
      moveEndHandler.cleanup();
      panHandler.cleanup();
      panEndHandler.cleanup();
      pressHandler.cleanup();
      pressEndHandler.cleanup();
    };
  }, [svgRef, yAxis, xAxis, voronoiMaxRadius, onItemClick, disableVoronoi, drawingArea, instance, seriesOrder, series, flatbushMap, defaultXAxisId, defaultYAxisId, store]);
  const enableVoronoiCallback = useEventCallback_default(() => {
    store.set("voronoi", {
      isVoronoiEnabled: true
    });
  });
  const disableVoronoiCallback = useEventCallback_default(() => {
    store.set("voronoi", {
      isVoronoiEnabled: false
    });
  });
  return {
    instance: {
      enableVoronoi: enableVoronoiCallback,
      disableVoronoi: disableVoronoiCallback
    }
  };
};
useChartClosestPoint.getDefaultizedParams = ({
  params
}) => _extends({}, params, {
  disableVoronoi: params.disableVoronoi ?? !params.series.some((item) => item.type === "scatter")
});
useChartClosestPoint.getInitialState = (params) => ({
  voronoi: {
    isVoronoiEnabled: !params.disableVoronoi
  }
});
useChartClosestPoint.params = {
  disableVoronoi: true,
  voronoiMaxRadius: true,
  onItemClick: true
};

// node_modules/@mui/x-charts/esm/internals/plugins/featurePlugins/useChartClosestPoint/useChartClosestPoint.selectors.js
var selectVoronoi = (state) => state.voronoi;
var selectorChartsIsVoronoiEnabled = createSelector([selectVoronoi], (voronoi) => voronoi == null ? void 0 : voronoi.isVoronoiEnabled);

// node_modules/@mui/x-charts/esm/internals/plugins/allPlugins.js
var DEFAULT_PLUGINS = [useChartZAxis, useChartBrush, useChartInteraction, useChartCartesianAxis, useChartHighlight, useChartClosestPoint, useChartKeyboardNavigation];

// node_modules/@mui/x-charts/esm/ChartDataProvider/useChartDataProviderProps.js
var _excluded15 = ["children", "localeText", "plugins", "seriesConfig", "slots", "slotProps"];
var useChartDataProviderProps = (inProps) => {
  const props = useThemeProps({
    props: inProps,
    name: "MuiChartDataProvider"
  });
  const {
    children,
    localeText,
    plugins = DEFAULT_PLUGINS,
    seriesConfig,
    slots,
    slotProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded15);
  const theme = useTheme();
  const chartProviderProps = {
    plugins,
    seriesConfig,
    pluginParams: _extends({
      theme: theme.palette.mode
    }, other)
  };
  return {
    children,
    localeText,
    chartProviderProps,
    slots,
    slotProps
  };
};

// node_modules/@mui/x-charts/esm/ChartDataProvider/ChartDataProvider.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
function ChartDataProvider(props) {
  const {
    children,
    localeText,
    chartProviderProps,
    slots,
    slotProps
  } = useChartDataProviderProps(props);
  return (0, import_jsx_runtime22.jsx)(ChartProvider, _extends({}, chartProviderProps, {
    children: (0, import_jsx_runtime22.jsx)(ChartsLocalizationProvider, {
      localeText,
      children: (0, import_jsx_runtime22.jsx)(ChartsSlotsProvider, {
        slots,
        slotProps,
        defaultSlots: defaultSlotsMaterial,
        children
      })
    })
  }));
}
true ? ChartDataProvider.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  apiRef: import_prop_types16.default.shape({
    current: import_prop_types16.default.any
  }),
  /**
   * Color palette used to colorize multiple series.
   * @default rainbowSurgePalette
   */
  colors: import_prop_types16.default.oneOfType([import_prop_types16.default.arrayOf(import_prop_types16.default.string), import_prop_types16.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types16.default.arrayOf(import_prop_types16.default.object),
  /**
   * Options to enable features planned for the next major.
   */
  experimentalFeatures: import_prop_types16.default.shape({
    preferStrictDomainInLineCharts: import_prop_types16.default.bool
  }),
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types16.default.number,
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types16.default.string,
  /**
   * Localized text for chart components.
   */
  localeText: import_prop_types16.default.object,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   *
   * Accepts a `number` to be used on all sides or an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   */
  margin: import_prop_types16.default.oneOfType([import_prop_types16.default.number, import_prop_types16.default.shape({
    bottom: import_prop_types16.default.number,
    left: import_prop_types16.default.number,
    right: import_prop_types16.default.number,
    top: import_prop_types16.default.number
  })]),
  /**
   * The array of series to display.
   * Each type of series has its own specificity.
   * Please refer to the appropriate docs page to learn more about it.
   */
  series: import_prop_types16.default.arrayOf(import_prop_types16.default.object),
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types16.default.bool,
  /**
   * The props for the slots.
   */
  slotProps: import_prop_types16.default.object,
  /**
   * Slots to customize charts' components.
   */
  slots: import_prop_types16.default.object,
  theme: import_prop_types16.default.oneOf(["dark", "light"]),
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types16.default.number
} : void 0;

// node_modules/@mui/x-charts/esm/ChartContainer/useChartContainerProps.js
var _excluded16 = ["width", "height", "margin", "children", "series", "colors", "dataset", "desc", "onAxisClick", "highlightedAxis", "onHighlightedAxisChange", "disableVoronoi", "voronoiMaxRadius", "onItemClick", "disableAxisListener", "highlightedItem", "onHighlightChange", "sx", "title", "xAxis", "yAxis", "zAxis", "rotationAxis", "radiusAxis", "skipAnimation", "seriesConfig", "plugins", "localeText", "slots", "slotProps", "experimentalFeatures", "enableKeyboardNavigation", "brushConfig"];
var useChartContainerProps = (props, ref) => {
  const _ref = props, {
    width,
    height,
    margin,
    children,
    series,
    colors,
    dataset,
    desc,
    onAxisClick,
    highlightedAxis,
    onHighlightedAxisChange,
    disableVoronoi,
    voronoiMaxRadius,
    onItemClick,
    disableAxisListener,
    highlightedItem,
    onHighlightChange,
    sx,
    title,
    xAxis,
    yAxis,
    zAxis,
    rotationAxis,
    radiusAxis,
    skipAnimation,
    seriesConfig,
    plugins,
    localeText,
    slots,
    slotProps,
    experimentalFeatures,
    enableKeyboardNavigation,
    brushConfig
  } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded16);
  const chartsSurfaceProps = _extends({
    title,
    desc,
    sx,
    ref
  }, other);
  const chartDataProviderProps = {
    margin,
    series,
    colors,
    dataset,
    disableAxisListener,
    highlightedItem,
    onHighlightChange,
    onAxisClick,
    highlightedAxis,
    onHighlightedAxisChange,
    disableVoronoi,
    voronoiMaxRadius,
    onItemClick,
    xAxis,
    yAxis,
    zAxis,
    rotationAxis,
    radiusAxis,
    skipAnimation,
    width,
    height,
    localeText,
    seriesConfig,
    experimentalFeatures,
    enableKeyboardNavigation,
    brushConfig,
    plugins: plugins ?? DEFAULT_PLUGINS,
    slots,
    slotProps
  };
  return {
    chartDataProviderProps,
    chartsSurfaceProps,
    children
  };
};

// node_modules/@mui/x-charts/esm/ChartsWrapper/ChartsWrapper.js
var React28 = __toESM(require_react(), 1);
var import_prop_types19 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/esm/Toolbar/Toolbar.js
var React26 = __toESM(require_react(), 1);
var import_prop_types17 = __toESM(require_prop_types(), 1);

// node_modules/@mui/x-charts/node_modules/@mui/x-internals/esm/useComponentRenderer/useComponentRenderer.js
var React23 = __toESM(require_react(), 1);
function useComponentRenderer(defaultElement, render, props, state = {}) {
  if (typeof render === "function") {
    return render(props, state);
  }
  if (render) {
    if (render.props.className) {
      props.className = mergeClassNames(render.props.className, props.className);
    }
    if (render.props.style || props.style) {
      props.style = _extends({}, props.style, render.props.style);
    }
    return React23.cloneElement(render, props);
  }
  return React23.createElement(defaultElement, props);
}
function mergeClassNames(className, otherClassName) {
  if (!className || !otherClassName) {
    return className || otherClassName;
  }
  return `${className} ${otherClassName}`;
}

// node_modules/@mui/x-charts/node_modules/@mui/x-internals/esm/ToolbarContext/ToolbarContext.js
var React24 = __toESM(require_react(), 1);
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var ToolbarContext = React24.createContext(void 0);
if (true) ToolbarContext.displayName = "ToolbarContext";
function useToolbarContext() {
  const context = React24.useContext(ToolbarContext);
  if (context === void 0) {
    throw new Error("MUI X: Missing context. Toolbar subcomponents must be placed within a <Toolbar /> component.");
  }
  return context;
}
function ToolbarContextProvider({
  children
}) {
  const [focusableItemId, setFocusableItemId] = React24.useState(null);
  const focusableItemIdRef = React24.useRef(focusableItemId);
  const [items, setItems] = React24.useState([]);
  const getSortedItems = React24.useCallback(() => items.sort(sortByDocumentPosition), [items]);
  const findEnabledItem = React24.useCallback((startIndex, step, wrap = true) => {
    var _a, _b;
    let index = startIndex;
    const sortedItems = getSortedItems();
    const itemCount = sortedItems.length;
    for (let i = 0; i < itemCount; i += 1) {
      index += step;
      if (index >= itemCount) {
        if (!wrap) {
          return -1;
        }
        index = 0;
      } else if (index < 0) {
        if (!wrap) {
          return -1;
        }
        index = itemCount - 1;
      }
      if (!((_a = sortedItems[index].ref.current) == null ? void 0 : _a.disabled) && ((_b = sortedItems[index].ref.current) == null ? void 0 : _b.ariaDisabled) !== "true") {
        return index;
      }
    }
    return -1;
  }, [getSortedItems]);
  const registerItem = React24.useCallback((id, itemRef) => {
    setItems((prevItems) => [...prevItems, {
      id,
      ref: itemRef
    }]);
  }, []);
  const unregisterItem = React24.useCallback((id) => {
    setItems((prevItems) => prevItems.filter((i) => i.id !== id));
  }, []);
  const onItemKeyDown = React24.useCallback((event) => {
    var _a;
    if (!focusableItemId) {
      return;
    }
    const sortedItems = getSortedItems();
    const focusableItemIndex = sortedItems.findIndex((item) => item.id === focusableItemId);
    let newIndex = -1;
    if (event.key === "ArrowRight") {
      event.preventDefault();
      newIndex = findEnabledItem(focusableItemIndex, 1);
    } else if (event.key === "ArrowLeft") {
      event.preventDefault();
      newIndex = findEnabledItem(focusableItemIndex, -1);
    } else if (event.key === "Home") {
      event.preventDefault();
      newIndex = findEnabledItem(-1, 1, false);
    } else if (event.key === "End") {
      event.preventDefault();
      newIndex = findEnabledItem(sortedItems.length, -1, false);
    }
    if (newIndex >= 0 && newIndex < sortedItems.length) {
      const item = sortedItems[newIndex];
      setFocusableItemId(item.id);
      (_a = item.ref.current) == null ? void 0 : _a.focus();
    }
  }, [getSortedItems, focusableItemId, findEnabledItem]);
  const onItemFocus = React24.useCallback((id) => {
    if (focusableItemId !== id) {
      setFocusableItemId(id);
    }
  }, [focusableItemId, setFocusableItemId]);
  const onItemDisabled = React24.useCallback((id) => {
    var _a;
    const sortedItems = getSortedItems();
    const currentIndex = sortedItems.findIndex((item) => item.id === id);
    const newIndex = findEnabledItem(currentIndex, 1);
    if (newIndex >= 0 && newIndex < sortedItems.length) {
      const item = sortedItems[newIndex];
      setFocusableItemId(item.id);
      (_a = item.ref.current) == null ? void 0 : _a.focus();
    }
  }, [getSortedItems, findEnabledItem]);
  React24.useEffect(() => {
    focusableItemIdRef.current = focusableItemId;
  }, [focusableItemId]);
  React24.useEffect(() => {
    var _a, _b;
    const sortedItems = getSortedItems();
    if (sortedItems.length > 0) {
      if (!focusableItemIdRef.current) {
        setFocusableItemId(sortedItems[0].id);
        return;
      }
      const focusableItemIndex = sortedItems.findIndex((item) => item.id === focusableItemIdRef.current);
      if (!sortedItems[focusableItemIndex]) {
        const item = sortedItems[sortedItems.length - 1];
        if (item) {
          setFocusableItemId(item.id);
          (_a = item.ref.current) == null ? void 0 : _a.focus();
        }
      } else if (focusableItemIndex === -1) {
        const item = sortedItems[focusableItemIndex];
        if (item) {
          setFocusableItemId(item.id);
          (_b = item.ref.current) == null ? void 0 : _b.focus();
        }
      }
    }
  }, [getSortedItems, findEnabledItem]);
  const contextValue = React24.useMemo(() => ({
    focusableItemId,
    registerItem,
    unregisterItem,
    onItemKeyDown,
    onItemFocus,
    onItemDisabled
  }), [focusableItemId, registerItem, unregisterItem, onItemKeyDown, onItemFocus, onItemDisabled]);
  return (0, import_jsx_runtime23.jsx)(ToolbarContext.Provider, {
    value: contextValue,
    children
  });
}
function sortByDocumentPosition(a, b) {
  if (!a.ref.current || !b.ref.current) {
    return 0;
  }
  const position = a.ref.current.compareDocumentPosition(b.ref.current);
  if (!position) {
    return 0;
  }
  if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {
    return -1;
  }
  if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {
    return 1;
  }
  return 0;
}

// node_modules/@mui/x-charts/node_modules/@mui/x-internals/esm/ToolbarContext/useRegisterToolbarButton.js
var React25 = __toESM(require_react(), 1);
function useRegisterToolbarButton(props, ref) {
  const {
    onKeyDown,
    onFocus,
    disabled,
    "aria-disabled": ariaDisabled
  } = props;
  const id = useId();
  const {
    focusableItemId,
    registerItem,
    unregisterItem,
    onItemKeyDown,
    onItemFocus,
    onItemDisabled
  } = useToolbarContext();
  const handleKeyDown = (event) => {
    onItemKeyDown(event);
    onKeyDown == null ? void 0 : onKeyDown(event);
  };
  const handleFocus = (event) => {
    onItemFocus(id);
    onFocus == null ? void 0 : onFocus(event);
  };
  React25.useEffect(() => {
    registerItem(id, ref);
    return () => unregisterItem(id);
  }, [id, ref, registerItem, unregisterItem]);
  const previousDisabled = React25.useRef(disabled);
  React25.useEffect(() => {
    if (previousDisabled.current !== disabled && disabled === true) {
      onItemDisabled(id, disabled);
    }
    previousDisabled.current = disabled;
  }, [disabled, id, onItemDisabled]);
  const previousAriaDisabled = React25.useRef(ariaDisabled);
  React25.useEffect(() => {
    if (previousAriaDisabled.current !== ariaDisabled && ariaDisabled === true) {
      onItemDisabled(id, true);
    }
    previousAriaDisabled.current = ariaDisabled;
  }, [ariaDisabled, id, onItemDisabled]);
  return {
    tabIndex: focusableItemId === id ? 0 : -1,
    disabled,
    "aria-disabled": ariaDisabled,
    onKeyDown: handleKeyDown,
    onFocus: handleFocus
  };
}

// node_modules/@mui/x-charts/esm/Toolbar/chartToolbarClasses.js
var chartsToolbarClasses = generateUtilityClasses("MuiChartsToolbar", ["root"]);

// node_modules/@mui/x-charts/esm/Toolbar/Toolbar.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var _excluded17 = ["className", "render"];
var ToolbarRoot = styled_default("div", {
  name: "MuiChartsToolbar",
  slot: "Root"
})(({
  theme
}) => ({
  flex: 0,
  display: "flex",
  alignItems: "center",
  justifyContent: "end",
  gap: theme.spacing(0.25),
  padding: theme.spacing(0.5),
  marginBottom: theme.spacing(1.5),
  minHeight: 44,
  boxSizing: "border-box",
  border: `1px solid ${(theme.vars || theme).palette.divider}`,
  borderRadius: 4
}));
var Toolbar = React26.forwardRef(function Toolbar2(_ref, ref) {
  let {
    className,
    render
  } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded17);
  const element = useComponentRenderer(ToolbarRoot, render, _extends({
    role: "toolbar",
    "aria-orientation": "horizontal",
    className: clsx_default(chartsToolbarClasses.root, className)
  }, other, {
    ref
  }));
  return (0, import_jsx_runtime24.jsx)(ToolbarContextProvider, {
    children: element
  });
});
if (true) Toolbar.displayName = "Toolbar";
true ? Toolbar.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  className: import_prop_types17.default.string,
  /**
   * A function to customize rendering of the component.
   */
  render: import_prop_types17.default.oneOfType([import_prop_types17.default.element, import_prop_types17.default.func])
} : void 0;

// node_modules/@mui/x-charts/esm/Toolbar/ToolbarButton.js
var import_prop_types18 = __toESM(require_prop_types(), 1);
var React27 = __toESM(require_react(), 1);
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var _excluded18 = ["render", "onKeyDown", "onFocus", "disabled", "aria-disabled"];
var _excluded23 = ["tabIndex"];
var ToolbarButton = React27.forwardRef(function ToolbarButton2(props, ref) {
  const {
    render
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded18);
  const {
    slots,
    slotProps
  } = useChartsSlots();
  const buttonRef = React27.useRef(null);
  const handleRef = useForkRef(buttonRef, ref);
  const _useRegisterToolbarBu = useRegisterToolbarButton(props, buttonRef), {
    tabIndex
  } = _useRegisterToolbarBu, toolbarButtonProps = _objectWithoutPropertiesLoose(_useRegisterToolbarBu, _excluded23);
  const element = useComponentRenderer(slots.baseIconButton, render, _extends({}, slotProps == null ? void 0 : slotProps.baseIconButton, {
    tabIndex
  }, other, toolbarButtonProps, {
    ref: handleRef
  }));
  return (0, import_jsx_runtime25.jsx)(React27.Fragment, {
    children: element
  });
});
if (true) ToolbarButton.displayName = "ToolbarButton";
true ? ToolbarButton.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  className: import_prop_types18.default.string,
  disabled: import_prop_types18.default.bool,
  id: import_prop_types18.default.string,
  /**
   * A function to customize the rendering of the component.
   */
  render: import_prop_types18.default.oneOfType([import_prop_types18.default.element, import_prop_types18.default.func]),
  size: import_prop_types18.default.oneOf(["large", "medium", "small"]),
  style: import_prop_types18.default.object,
  tabIndex: import_prop_types18.default.number
} : void 0;

// node_modules/@mui/x-charts/esm/ChartsWrapper/ChartsWrapper.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var getJustifyItems = (position) => {
  if ((position == null ? void 0 : position.horizontal) === "start") {
    return "start";
  }
  if ((position == null ? void 0 : position.horizontal) === "end") {
    return "end";
  }
  return "center";
};
var getAlignItems = (position) => {
  if ((position == null ? void 0 : position.vertical) === "top") {
    return "flex-start";
  }
  if ((position == null ? void 0 : position.vertical) === "bottom") {
    return "flex-end";
  }
  return "center";
};
var getGridTemplateAreas = (hideLegend, direction, position) => {
  if (hideLegend) {
    return `"chart"`;
  }
  if (direction === "vertical") {
    if ((position == null ? void 0 : position.horizontal) === "start") {
      return `"legend chart"`;
    }
    return `"chart legend"`;
  }
  if ((position == null ? void 0 : position.vertical) === "bottom") {
    return `"chart"
            "legend"`;
  }
  return `"legend"
          "chart"`;
};
var getTemplateColumns = (hideLegend = false, direction = "horizontal", horizontalPosition = "end", width = void 0) => {
  const drawingAreaColumn = width ? "auto" : "1fr";
  if (direction === "horizontal") {
    return drawingAreaColumn;
  }
  if (hideLegend) {
    return drawingAreaColumn;
  }
  return horizontalPosition === "start" ? `auto ${drawingAreaColumn}` : `${drawingAreaColumn} auto`;
};
var getTemplateRows = (hideLegend = false, direction = "horizontal", verticalPosition = "top") => {
  const drawingAreaRow = "1fr";
  if (direction === "vertical") {
    return drawingAreaRow;
  }
  if (hideLegend) {
    return drawingAreaRow;
  }
  return verticalPosition === "bottom" ? `${drawingAreaRow} auto` : `auto ${drawingAreaRow}`;
};
var Root3 = styled_default("div", {
  name: "MuiChartsWrapper",
  slot: "Root",
  shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "extendVertically" && prop !== "width"
})(({
  ownerState,
  width
}) => {
  var _a, _b;
  const gridTemplateColumns = getTemplateColumns(ownerState.hideLegend, ownerState.legendDirection, (_a = ownerState.legendPosition) == null ? void 0 : _a.horizontal, width);
  const gridTemplateRows = getTemplateRows(ownerState.hideLegend, ownerState.legendDirection, (_b = ownerState.legendPosition) == null ? void 0 : _b.vertical);
  const gridTemplateAreas = getGridTemplateAreas(ownerState.hideLegend, ownerState.legendDirection, ownerState.legendPosition);
  return {
    variants: [{
      props: {
        extendVertically: true
      },
      style: {
        height: "100%",
        minHeight: 0
      }
    }],
    flex: 1,
    display: "grid",
    gridTemplateColumns,
    gridTemplateRows,
    gridTemplateAreas,
    [`&:has(.${chartsToolbarClasses.root})`]: {
      // Add a row for toolbar if there is one.
      gridTemplateRows: `auto ${gridTemplateRows}`,
      gridTemplateAreas: `"${gridTemplateColumns.split(" ").map(() => "toolbar").join(" ")}"
        ${gridTemplateAreas}`
    },
    [`& .${chartsToolbarClasses.root}`]: {
      gridArea: "toolbar",
      justifySelf: "center"
    },
    justifyContent: "safe center",
    justifyItems: getJustifyItems(ownerState.legendPosition),
    alignItems: getAlignItems(ownerState.legendPosition)
  };
});
function ChartsWrapper(props) {
  const {
    children,
    sx,
    extendVertically
  } = props;
  const chartRootRef = useChartRootRef();
  const store = useStore();
  const propsWidth = useSelector(store, selectorChartPropsWidth);
  const propsHeight = useSelector(store, selectorChartPropsHeight);
  return (0, import_jsx_runtime26.jsx)(Root3, {
    ref: chartRootRef,
    ownerState: props,
    sx,
    extendVertically: extendVertically ?? propsHeight === void 0,
    width: propsWidth,
    children
  });
}
true ? ChartsWrapper.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types19.default.node,
  /**
   * If `true`, the chart wrapper set `height: 100%`.
   * @default `false` if the `height` prop is set. And `true` otherwise.
   */
  extendVertically: import_prop_types19.default.bool,
  /**
   * If `true`, the legend is not rendered.
   * @default false
   */
  hideLegend: import_prop_types19.default.bool,
  /**
   * The direction of the legend.
   * @default 'horizontal'
   */
  legendDirection: import_prop_types19.default.oneOf(["horizontal", "vertical"]),
  /**
   * The position of the legend.
   * @default { horizontal: 'center', vertical: 'bottom' }
   */
  legendPosition: import_prop_types19.default.shape({
    horizontal: import_prop_types19.default.oneOf(["center", "end", "start"]),
    vertical: import_prop_types19.default.oneOf(["bottom", "middle", "top"])
  }),
  sx: import_prop_types19.default.oneOfType([import_prop_types19.default.arrayOf(import_prop_types19.default.oneOfType([import_prop_types19.default.func, import_prop_types19.default.object, import_prop_types19.default.bool])), import_prop_types19.default.func, import_prop_types19.default.object])
} : void 0;

// node_modules/@mui/x-charts/esm/PieChart/PieChart.plugins.js
var PIE_CHART_PLUGINS = [useChartInteraction, useChartHighlight, useChartKeyboardNavigation];

// node_modules/@mui/x-charts/esm/PieChart/PieChart.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var _excluded19 = ["series", "width", "height", "margin", "colors", "sx", "skipAnimation", "hideLegend", "children", "slots", "slotProps", "onItemClick", "loading", "highlightedItem", "onHighlightChange", "className", "showToolbar"];
var PieChart = React29.forwardRef(function PieChart2(inProps, ref) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const props = useThemeProps({
    props: inProps,
    name: "MuiPieChart"
  });
  const {
    series,
    width,
    height,
    margin: marginProps,
    colors,
    sx,
    skipAnimation,
    hideLegend,
    children,
    slots,
    slotProps,
    onItemClick,
    loading,
    highlightedItem,
    onHighlightChange,
    className,
    showToolbar
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded19);
  const margin = defaultizeMargin(marginProps, DEFAULT_PIE_CHART_MARGIN);
  const {
    chartDataProviderProps,
    chartsSurfaceProps
  } = useChartContainerProps(_extends({}, other, {
    series: series.map((s) => _extends({
      type: "pie"
    }, s)),
    width,
    height,
    margin,
    colors,
    highlightedItem,
    onHighlightChange,
    className,
    skipAnimation,
    plugins: PIE_CHART_PLUGINS
  }), ref);
  const Tooltip = (slots == null ? void 0 : slots.tooltip) ?? ChartsTooltip;
  const Toolbar3 = (_a = props.slots) == null ? void 0 : _a.toolbar;
  return (0, import_jsx_runtime27.jsx)(ChartDataProvider, _extends({}, chartDataProviderProps, {
    children: (0, import_jsx_runtime27.jsxs)(ChartsWrapper, {
      legendPosition: (_c = (_b = props.slotProps) == null ? void 0 : _b.legend) == null ? void 0 : _c.position,
      legendDirection: ((_e = (_d = props.slotProps) == null ? void 0 : _d.legend) == null ? void 0 : _e.direction) ?? "vertical",
      sx,
      hideLegend: hideLegend ?? false,
      children: [showToolbar && Toolbar3 ? (0, import_jsx_runtime27.jsx)(Toolbar3, _extends({}, (_f = props.slotProps) == null ? void 0 : _f.toolbar)) : null, !hideLegend && (0, import_jsx_runtime27.jsx)(ChartsLegend, {
        direction: ((_h = (_g = props.slotProps) == null ? void 0 : _g.legend) == null ? void 0 : _h.direction) ?? "vertical",
        slots,
        slotProps
      }), (0, import_jsx_runtime27.jsxs)(ChartsSurface, _extends({}, chartsSurfaceProps, {
        children: [(0, import_jsx_runtime27.jsx)(PiePlot, {
          slots,
          slotProps,
          onItemClick
        }), (0, import_jsx_runtime27.jsx)(ChartsOverlay, {
          loading,
          slots,
          slotProps
        }), children]
      })), !loading && (0, import_jsx_runtime27.jsx)(Tooltip, _extends({
        trigger: "item"
      }, slotProps == null ? void 0 : slotProps.tooltip))]
    })
  }));
});
if (true) PieChart.displayName = "PieChart";
true ? PieChart.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  apiRef: import_prop_types20.default.shape({
    current: import_prop_types20.default.object
  }),
  children: import_prop_types20.default.node,
  className: import_prop_types20.default.string,
  /**
   * Color palette used to colorize multiple series.
   * @default rainbowSurgePalette
   */
  colors: import_prop_types20.default.oneOfType([import_prop_types20.default.arrayOf(import_prop_types20.default.string), import_prop_types20.default.func]),
  /**
   * An array of objects that can be used to populate series and axes data using their `dataKey` property.
   */
  dataset: import_prop_types20.default.arrayOf(import_prop_types20.default.object),
  desc: import_prop_types20.default.string,
  enableKeyboardNavigation: import_prop_types20.default.bool,
  /**
   * The height of the chart in px. If not defined, it takes the height of the parent element.
   */
  height: import_prop_types20.default.number,
  /**
   * If `true`, the legend is not rendered.
   */
  hideLegend: import_prop_types20.default.bool,
  /**
   * The highlighted item.
   * Used when the highlight is controlled.
   */
  highlightedItem: import_prop_types20.default.shape({
    dataIndex: import_prop_types20.default.number,
    seriesId: import_prop_types20.default.oneOfType([import_prop_types20.default.number, import_prop_types20.default.string]).isRequired
  }),
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types20.default.string,
  /**
   * If `true`, a loading overlay is displayed.
   * @default false
   */
  loading: import_prop_types20.default.bool,
  /**
   * Localized text for chart components.
   */
  localeText: import_prop_types20.default.object,
  /**
   * The margin between the SVG and the drawing area.
   * It's used for leaving some space for extra information such as the x- and y-axis or legend.
   *
   * Accepts a `number` to be used on all sides or an object with the optional properties: `top`, `bottom`, `left`, and `right`.
   */
  margin: import_prop_types20.default.oneOfType([import_prop_types20.default.number, import_prop_types20.default.shape({
    bottom: import_prop_types20.default.number,
    left: import_prop_types20.default.number,
    right: import_prop_types20.default.number,
    top: import_prop_types20.default.number
  })]),
  /**
   * The callback fired when the highlighted item changes.
   *
   * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
   */
  onHighlightChange: import_prop_types20.default.func,
  /**
   * Callback fired when a pie arc is clicked.
   */
  onItemClick: import_prop_types20.default.func,
  /**
   * The series to display in the pie chart.
   * An array of [[PieSeries]] objects.
   */
  series: import_prop_types20.default.arrayOf(import_prop_types20.default.object).isRequired,
  /**
   * If true, shows the default chart toolbar.
   * @default false
   */
  showToolbar: import_prop_types20.default.bool,
  /**
   * If `true`, animations are skipped.
   * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
   */
  skipAnimation: import_prop_types20.default.bool,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types20.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types20.default.object,
  sx: import_prop_types20.default.oneOfType([import_prop_types20.default.arrayOf(import_prop_types20.default.oneOfType([import_prop_types20.default.func, import_prop_types20.default.object, import_prop_types20.default.bool])), import_prop_types20.default.func, import_prop_types20.default.object]),
  theme: import_prop_types20.default.oneOf(["dark", "light"]),
  title: import_prop_types20.default.string,
  /**
   * The width of the chart in px. If not defined, it takes the width of the parent element.
   */
  width: import_prop_types20.default.number
} : void 0;
export {
  PIE_CHART_PLUGINS,
  PieArc,
  PieArcLabel,
  PieArcLabelPlot,
  PieArcPlot,
  PieChart,
  PiePlot,
  getPieArcLabelUtilityClass,
  getPieArcUtilityClass,
  getPieCoordinates,
  pieArcClasses,
  pieArcLabelClasses,
  pieClasses
};
//# sourceMappingURL=@mui_x-charts_PieChart.js.map
